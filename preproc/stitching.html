<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pvinspect.preproc.stitching API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pvinspect.preproc.stitching</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from pvinspect.data import ModuleImage, ModuleImageSequence
from pvinspect.data.image import Image, ImageSequence, Modality
from pvinspect.preproc.detection import locate_module_and_cells, segment_module_part


def _stitch_two(
    img1: Image, img2: Image, cell_size: int, overlap: int, direction: str
) -&gt; Image:
    if direction == &#34;hor&#34;:
        img1 = segment_module_part(
            img1,
            0,
            0,
            img1.get_meta(&#34;cols&#34;) - (overlap // 2),
            img1.get_meta(&#34;rows&#34;),
            cell_size,
        )
        img2 = segment_module_part(
            img2,
            overlap // 2,
            0,
            img2.get_meta(&#34;cols&#34;) - (overlap // 2),
            img2.get_meta(&#34;rows&#34;),
            cell_size,
        )
        return img1.from_self(
            data=np.concatenate([img1.data, img2.data], axis=1),
            meta=dict(cols=img1.get_meta(&#34;cols&#34;) + img2.get_meta(&#34;cols&#34;) - overlap),
        )
    else:
        img1 = segment_module_part(
            img1,
            0,
            0,
            img1.get_meta(&#34;cols&#34;),
            img1.get_meta(&#34;rows&#34;) - (overlap // 2),
            cell_size,
        )
        img2 = segment_module_part(
            img2,
            0,
            overlap // 2,
            img2.get_meta(&#34;cols&#34;),
            img2.get_meta(&#34;rows&#34;) - (overlap // 2),
            cell_size,
        )
        return img1.from_self(
            data=np.concatenate([img1.data, img2.data], axis=0),
            meta=dict(rows=img1.get_meta(&#34;rows&#34;) + img2.get_meta(&#34;rows&#34;) - overlap),
        )


def _scale_median_brightness(x: np.ndarray, target: float) -&gt; np.ndarray:
    source = np.median(x)
    return (x * (target / source)).astype(x.dtype)


def stitch_modules(
    images: ImageSequence,
    n_horizontal: int = 1,
    n_vertical: int = 1,
    overlap_horizontal: int = 0,
    overlap_vertical: int = 0,
    equalize_intensity: bool = False,
) -&gt; Image:
    &#34;&#34;&#34;Locate and stitch partial recordings of a module

    Args:
        images (ImageSequence): Partial recordings to be stitched together (needs to be order left -&gt; right / top -&gt; bottom)
        n_horizontal (int): Number of partial recordings in horizontal direction
        n_vertical (int): Number of partial recordings in vertical direction
        overlap_horizontal (int): Number of fully visible cells that overlap between any two partial recordings
            in horizontal direction
        overlap_vertical (int): Number of fully visible cells that overlap between any two partial recordings
            in vertical direction
        equalize_intenity (bool): Match the median intensity of every partial recording to the median intensity of the first

    Returns:
        image (Image): The stitched image
    &#34;&#34;&#34;

    if n_horizontal &lt; 1 or n_vertical &lt; 1:
        raise RuntimeError(
            &#34;Number of images for stitching must not be smaller than 1 in any direction&#34;
        )

    if n_horizontal &gt; 2 or n_vertical &gt; 2:
        raise NotImplementedError(
            &#34;Stitching is only implemented for configurations 1x2, 2x1 and 2x2&#34;
        )

    if overlap_horizontal &lt; 0 or overlap_vertical &lt; 0:
        raise RuntimeError(&#34;Invalid overlap&#34;)

    if overlap_horizontal % 2 != 0 or overlap_vertical % 2 != 0:
        raise NotImplementedError(&#34;Stitching is only implemented for even overlap&#34;)

    # determine spacing based on first image
    t = images[0].get_meta(&#34;transform&#34;)
    cell_size = np.linalg.norm(
        t(np.array([[1.0, 1.0]]))[0] - t(np.array([[0.0, 0.0]]))[0]
    )

    # equalize brightness if set
    if equalize_intensity:
        ref = np.median(images[0].data)  # use the first image as reference
        images = images.apply_image_data(_scale_median_brightness, target=ref)

    # stitch
    if n_horizontal == 1 and n_vertical == 1:
        return images[0]
    elif n_horizontal == 2 and n_vertical == 1:
        return _stitch_two(images[0], images[1], cell_size, overlap_horizontal, &#34;hor&#34;)
    elif n_horizontal == 1 and n_vertical == 2:
        return _stitch_two(images[0], images[1], cell_size, overlap_vertical, &#34;ver&#34;)
    else:  # n_horizontal == 2 and n_vertical == 2
        row1 = _stitch_two(images[0], images[1], cell_size, overlap_horizontal, &#34;hor&#34;)
        row2 = _stitch_two(images[2], images[3], cell_size, overlap_horizontal, &#34;hor&#34;)
        return row1.from_self(
            data=np.concatenate([row1.data, row2.data], axis=0),
            meta=dict(rows=row1.get_meta(&#34;rows&#34;) + row2.get_meta(&#34;rows&#34;)),
        )


# def locate_and_stitch_modules(images: ImageSequence, n_horizontal: int = 1, )
def locate_and_stitch_modules(
    images: ImageSequence,
    rows: int,
    cols: int,
    n_horizontal: int = 1,
    n_vertical: int = 1,
    overlap_horizontal: int = 0,
    overlap_vertical: int = 0,
    enable_background_suppression: bool = True,
    equalize_intensity: bool = False,
) -&gt; Image:
    &#34;&#34;&#34;Locate and stitch partial recordings of a module

    This method applies localization of modules followed by stitching. It relies on an exact specification
    of the visible module geometry (by means of rows, cols, n_horizontal, n_vertical, overlap_horizontal,
    overlap_vertical). Furthermore images need to be given in the specified order.

    This method optionally provides adaptation of intensities of the partial recordings. This is turned off
    by default, since it changes the original intensities, which might be undesirable in some cases.

    Args:
        images (ImageSequence): Partial recordings to be stitched together (needs to be order left -&gt; right / top -&gt; bottom)
        rows (int): Number of fully visible rows of cells in every partial recording
        cols (int): Number of fully visible columns of cells in every partial recording
        n_horizontal (int): Number of partial recordings in horizontal direction
        n_vertical (int): Number of partial recordings in vertical direction
        overlap_horizontal (int): Number of fully visible cells that overlap between any two partial recordings
            in horizontal direction
        overlap_vertical (int): Number of fully visible cells that overlap between any two partial recordings
            in vertical direction
        enable_background_suppression (bool): Enable the background suppression for the module detection. This sometimes causes
            problems with PL images and disabling it might help.
        equalize_intensity (bool): Match the median intensity of every partial recording to the median intensity of the first

    Returns:
        image (Image): The stitched image
    &#34;&#34;&#34;

    modimages = ModuleImageSequence(
        [
            ModuleImage(x.data, modality=Modality.EL_IMAGE, cols=cols, rows=rows)
            for x in images
        ]
    )

    # locate
    modimages = locate_module_and_cells(
        modimages,
        orientation=&#34;horizontal&#34;,
        enable_background_suppresion=enable_background_suppression,
    )

    # stitch
    return stitch_modules(
        modimages,
        n_horizontal,
        n_vertical,
        overlap_horizontal,
        overlap_vertical,
        equalize_intensity,
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pvinspect.preproc.stitching.locate_and_stitch_modules"><code class="name flex">
<span>def <span class="ident">locate_and_stitch_modules</span></span>(<span>images: <a title="pvinspect.data.image.ImageSequence" href="../data/image.html#pvinspect.data.image.ImageSequence">ImageSequence</a>, rows: int, cols: int, n_horizontal: int = 1, n_vertical: int = 1, overlap_horizontal: int = 0, overlap_vertical: int = 0, enable_background_suppression: bool = True, equalize_intensity: bool = False) ‑> <a title="pvinspect.data.image.Image" href="../data/image.html#pvinspect.data.image.Image">Image</a></span>
</code></dt>
<dd>
<div class="desc"><p>Locate and stitch partial recordings of a module</p>
<p>This method applies localization of modules followed by stitching. It relies on an exact specification
of the visible module geometry (by means of rows, cols, n_horizontal, n_vertical, overlap_horizontal,
overlap_vertical). Furthermore images need to be given in the specified order.</p>
<p>This method optionally provides adaptation of intensities of the partial recordings. This is turned off
by default, since it changes the original intensities, which might be undesirable in some cases.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>ImageSequence</code></dt>
<dd>Partial recordings to be stitched together (needs to be order left -&gt; right / top -&gt; bottom)</dd>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of fully visible rows of cells in every partial recording</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of fully visible columns of cells in every partial recording</dd>
<dt><strong><code>n_horizontal</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of partial recordings in horizontal direction</dd>
<dt><strong><code>n_vertical</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of partial recordings in vertical direction</dd>
<dt><strong><code>overlap_horizontal</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of fully visible cells that overlap between any two partial recordings
in horizontal direction</dd>
<dt><strong><code>overlap_vertical</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of fully visible cells that overlap between any two partial recordings
in vertical direction</dd>
<dt><strong><code>enable_background_suppression</code></strong> :&ensp;<code>bool</code></dt>
<dd>Enable the background suppression for the module detection. This sometimes causes
problems with PL images and disabling it might help.</dd>
<dt><strong><code>equalize_intensity</code></strong> :&ensp;<code>bool</code></dt>
<dd>Match the median intensity of every partial recording to the median intensity of the first</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>image (Image): The stitched image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def locate_and_stitch_modules(
    images: ImageSequence,
    rows: int,
    cols: int,
    n_horizontal: int = 1,
    n_vertical: int = 1,
    overlap_horizontal: int = 0,
    overlap_vertical: int = 0,
    enable_background_suppression: bool = True,
    equalize_intensity: bool = False,
) -&gt; Image:
    &#34;&#34;&#34;Locate and stitch partial recordings of a module

    This method applies localization of modules followed by stitching. It relies on an exact specification
    of the visible module geometry (by means of rows, cols, n_horizontal, n_vertical, overlap_horizontal,
    overlap_vertical). Furthermore images need to be given in the specified order.

    This method optionally provides adaptation of intensities of the partial recordings. This is turned off
    by default, since it changes the original intensities, which might be undesirable in some cases.

    Args:
        images (ImageSequence): Partial recordings to be stitched together (needs to be order left -&gt; right / top -&gt; bottom)
        rows (int): Number of fully visible rows of cells in every partial recording
        cols (int): Number of fully visible columns of cells in every partial recording
        n_horizontal (int): Number of partial recordings in horizontal direction
        n_vertical (int): Number of partial recordings in vertical direction
        overlap_horizontal (int): Number of fully visible cells that overlap between any two partial recordings
            in horizontal direction
        overlap_vertical (int): Number of fully visible cells that overlap between any two partial recordings
            in vertical direction
        enable_background_suppression (bool): Enable the background suppression for the module detection. This sometimes causes
            problems with PL images and disabling it might help.
        equalize_intensity (bool): Match the median intensity of every partial recording to the median intensity of the first

    Returns:
        image (Image): The stitched image
    &#34;&#34;&#34;

    modimages = ModuleImageSequence(
        [
            ModuleImage(x.data, modality=Modality.EL_IMAGE, cols=cols, rows=rows)
            for x in images
        ]
    )

    # locate
    modimages = locate_module_and_cells(
        modimages,
        orientation=&#34;horizontal&#34;,
        enable_background_suppresion=enable_background_suppression,
    )

    # stitch
    return stitch_modules(
        modimages,
        n_horizontal,
        n_vertical,
        overlap_horizontal,
        overlap_vertical,
        equalize_intensity,
    )</code></pre>
</details>
</dd>
<dt id="pvinspect.preproc.stitching.stitch_modules"><code class="name flex">
<span>def <span class="ident">stitch_modules</span></span>(<span>images: <a title="pvinspect.data.image.ImageSequence" href="../data/image.html#pvinspect.data.image.ImageSequence">ImageSequence</a>, n_horizontal: int = 1, n_vertical: int = 1, overlap_horizontal: int = 0, overlap_vertical: int = 0, equalize_intensity: bool = False) ‑> <a title="pvinspect.data.image.Image" href="../data/image.html#pvinspect.data.image.Image">Image</a></span>
</code></dt>
<dd>
<div class="desc"><p>Locate and stitch partial recordings of a module</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>ImageSequence</code></dt>
<dd>Partial recordings to be stitched together (needs to be order left -&gt; right / top -&gt; bottom)</dd>
<dt><strong><code>n_horizontal</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of partial recordings in horizontal direction</dd>
<dt><strong><code>n_vertical</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of partial recordings in vertical direction</dd>
<dt><strong><code>overlap_horizontal</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of fully visible cells that overlap between any two partial recordings
in horizontal direction</dd>
<dt><strong><code>overlap_vertical</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of fully visible cells that overlap between any two partial recordings
in vertical direction</dd>
<dt><strong><code>equalize_intenity</code></strong> :&ensp;<code>bool</code></dt>
<dd>Match the median intensity of every partial recording to the median intensity of the first</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>image (Image): The stitched image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stitch_modules(
    images: ImageSequence,
    n_horizontal: int = 1,
    n_vertical: int = 1,
    overlap_horizontal: int = 0,
    overlap_vertical: int = 0,
    equalize_intensity: bool = False,
) -&gt; Image:
    &#34;&#34;&#34;Locate and stitch partial recordings of a module

    Args:
        images (ImageSequence): Partial recordings to be stitched together (needs to be order left -&gt; right / top -&gt; bottom)
        n_horizontal (int): Number of partial recordings in horizontal direction
        n_vertical (int): Number of partial recordings in vertical direction
        overlap_horizontal (int): Number of fully visible cells that overlap between any two partial recordings
            in horizontal direction
        overlap_vertical (int): Number of fully visible cells that overlap between any two partial recordings
            in vertical direction
        equalize_intenity (bool): Match the median intensity of every partial recording to the median intensity of the first

    Returns:
        image (Image): The stitched image
    &#34;&#34;&#34;

    if n_horizontal &lt; 1 or n_vertical &lt; 1:
        raise RuntimeError(
            &#34;Number of images for stitching must not be smaller than 1 in any direction&#34;
        )

    if n_horizontal &gt; 2 or n_vertical &gt; 2:
        raise NotImplementedError(
            &#34;Stitching is only implemented for configurations 1x2, 2x1 and 2x2&#34;
        )

    if overlap_horizontal &lt; 0 or overlap_vertical &lt; 0:
        raise RuntimeError(&#34;Invalid overlap&#34;)

    if overlap_horizontal % 2 != 0 or overlap_vertical % 2 != 0:
        raise NotImplementedError(&#34;Stitching is only implemented for even overlap&#34;)

    # determine spacing based on first image
    t = images[0].get_meta(&#34;transform&#34;)
    cell_size = np.linalg.norm(
        t(np.array([[1.0, 1.0]]))[0] - t(np.array([[0.0, 0.0]]))[0]
    )

    # equalize brightness if set
    if equalize_intensity:
        ref = np.median(images[0].data)  # use the first image as reference
        images = images.apply_image_data(_scale_median_brightness, target=ref)

    # stitch
    if n_horizontal == 1 and n_vertical == 1:
        return images[0]
    elif n_horizontal == 2 and n_vertical == 1:
        return _stitch_two(images[0], images[1], cell_size, overlap_horizontal, &#34;hor&#34;)
    elif n_horizontal == 1 and n_vertical == 2:
        return _stitch_two(images[0], images[1], cell_size, overlap_vertical, &#34;ver&#34;)
    else:  # n_horizontal == 2 and n_vertical == 2
        row1 = _stitch_two(images[0], images[1], cell_size, overlap_horizontal, &#34;hor&#34;)
        row2 = _stitch_two(images[2], images[3], cell_size, overlap_horizontal, &#34;hor&#34;)
        return row1.from_self(
            data=np.concatenate([row1.data, row2.data], axis=0),
            meta=dict(rows=row1.get_meta(&#34;rows&#34;) + row2.get_meta(&#34;rows&#34;)),
        )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pvinspect.preproc" href="index.html">pvinspect.preproc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pvinspect.preproc.stitching.locate_and_stitch_modules" href="#pvinspect.preproc.stitching.locate_and_stitch_modules">locate_and_stitch_modules</a></code></li>
<li><code><a title="pvinspect.preproc.stitching.stitch_modules" href="#pvinspect.preproc.stitching.stitch_modules">stitch_modules</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>