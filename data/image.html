<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pvinspect.data.image API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pvinspect.data.image</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations


&#34;&#34;&#34;Provides classes to store and visualize images with metadata&#34;&#34;&#34;

import numpy as np
from skimage import io, img_as_uint, img_as_float64, img_as_int
from pvinspect.common.transform import Transform
from matplotlib import pyplot as plt
from pathlib import Path
from typing import List, Optional, Tuple, Union, Callable, Type, TypeVar, Any, Dict
import copy
import math
from functools import wraps
import logging
from pvinspect.common._ipy_exit import exit
import inspect
import sys
from enum import Enum
import re
import pandas as pd
from tqdm.autonotebook import tqdm
from functools import partial, lru_cache

# this is a pointer to the module object instance itself
this = sys.modules[__name__]


# modality
class Modality(Enum):
    EL_IMAGE = (0,)
    PL_IMAGE = 1


EL_IMAGE = Modality.EL_IMAGE
&#34;&#34;&#34;Indicate an electroluminescense (EL) image&#34;&#34;&#34;
PL_IMAGE = Modality.PL_IMAGE
&#34;&#34;&#34;Indicate a photoluminescense (PL) image&#34;&#34;&#34;


# datatypes
DTYPE_INT = np.int32
DTYPE_UNSIGNED_INT = np.uint16
DTYPE_UNSIGNED_BYTE = np.uint8
DTYPE_FLOAT = np.float64
img_as_float = img_as_float64

# caching
SEQUENCE_MAX_CACHE_SIZE = 5000


class DType(Enum):
    INT = 0
    UNSIGNED_INT = 1
    FLOAT = 2
    UNSIGNED_BYTE = 3


# global list of plugins that are called on every .show()
this.show_plugins = list()


def register_show_plugin(callable, priority: int = 0):
    &#34;&#34;&#34;Register a new plugin that is called on every .show()

    Args:
        callable: Callable that receives the image as a first argument and variable arguments to .show() next
        priority (int): Plugins are invoked in the order of increasing priority (highest priority is invoked
            last and hence appears on top)
    &#34;&#34;&#34;
    this.show_plugins.append((priority, callable))
    this.show_plugins = sorted(this.show_plugins, key=lambda x: x[0])


def _invoke_show_plugins(image, **kwargs):
    for p in this.show_plugins:
        p[1](image, **kwargs)


def _register_default_plugins():
    def show_cell_crossings(
        image: ModuleImage, show_cell_crossings: bool = True, **kwargs
    ):
        if (
            show_cell_crossings
            and isinstance(image, ModuleImage)
            and image.has_meta(&#34;transform&#34;)
        ):
            grid = image.grid()
            coords = image.get_meta(&#34;transform&#34;).__call__(grid)
            plt.scatter(coords[:, 0], coords[:, 1], c=&#34;yellow&#34;, marker=&#34;+&#34;)

    register_show_plugin(show_cell_crossings)

    def multimodule_show_boxes(
        image: Image,
        multimodule_show_boxes: bool = True,
        multimodule_highlight_selection: bool = True,
        multimodule_boxes_linewidth: int = 2,
        **kwargs
    ):
        if (
            multimodule_show_boxes
            and isinstance(image, Image)
            and image.has_meta(&#34;multimodule_boxes&#34;)
        ):
            for i, box in enumerate(image.get_meta(&#34;multimodule_boxes&#34;)):
                color = (
                    &#34;red&#34;
                    if i == image.get_meta(&#34;multimodule_index&#34;)
                    and multimodule_highlight_selection
                    else &#34;yellow&#34;
                )
                plt.plot(
                    *box[1].exterior.xy,
                    linewidth=multimodule_boxes_linewidth,
                    color=color,
                )

    register_show_plugin(multimodule_show_boxes)

    def multimodule_show_numbers(
        image: Image,
        multimodule_show_numbers: bool = True,
        multimodule_highlight_selection: bool = True,
        multimodule_numbers_fontsize: int = 20,
        **kwargs
    ):
        if (
            multimodule_show_numbers
            and isinstance(image, Image)
            and image.has_meta(&#34;multimodule_boxes&#34;)
        ):
            for i, box in enumerate(image.get_meta(&#34;multimodule_boxes&#34;)):
                bgcolor = (
                    &#34;red&#34;
                    if i == image.get_meta(&#34;multimodule_index&#34;)
                    and multimodule_highlight_selection
                    else &#34;white&#34;
                )
                textcolor = (
                    &#34;white&#34;
                    if i == image.get_meta(&#34;multimodule_index&#34;)
                    and multimodule_highlight_selection
                    else &#34;black&#34;
                )
                plt.text(
                    box[1].centroid.x,
                    box[1].centroid.y,
                    s=str(i),
                    color=textcolor,
                    fontsize=multimodule_numbers_fontsize,
                    bbox=dict(facecolor=bgcolor, alpha=0.8),
                    ha=&#34;center&#34;,
                    va=&#34;center&#34;,
                )

    register_show_plugin(multimodule_show_numbers)

    def calibration_show_reference_box(
        image: Image,
        calibration_show_reference_box: bool = True,
        calibration_reference_box_color=&#34;red&#34;,
        **kwargs
    ):
        if (
            calibration_show_reference_box
            and isinstance(image, Image)
            and image.has_meta(&#34;calibration_reference_box&#34;)
        ):
            plt.plot(
                *image.get_meta(&#34;calibration_reference_box&#34;).exterior.xy,
                # linewidth=multimodule_boxes_linewidth,
                color=calibration_reference_box_color,
            )

    register_show_plugin(calibration_show_reference_box)

    def segment_module_show_box(
        image: Image,
        segment_module_show_box: bool = True,
        segment_module_show_box_color=&#34;red&#34;,
        **kwargs
    ):
        if (
            segment_module_show_box
            and isinstance(image, Image)
            and image.has_meta(&#34;segment_module_original_box&#34;)
        ):
            plt.plot(
                *image.get_meta(&#34;segment_module_original_box&#34;).exterior.xy,
                color=segment_module_show_box_color,
            )

    register_show_plugin(segment_module_show_box)

    def show_image(
        image: Image,
        clip_low: float = 0.001,
        clip_high: float = 99.999,
        colorbar: bool = True,
        **kwargs
    ):
        clip_low = clip_low if clip_low is not None else 0.0
        clip_high = clip_high if clip_high is not None else 100.0
        p = np.percentile(image._data, [clip_low, clip_high])
        d = np.clip(image._data, p[0], p[1])
        plt.imshow(d, cmap=&#34;gray&#34;)
        if colorbar:
            plt.colorbar()

    register_show_plugin(show_image, -100)

    def axis_options(
        image: Image,
        show_axis: bool = True,
        show_title: bool = True,
        max_title_length: bool = 30,
        **kwargs
    ):
        if not show_axis:
            plt.axis(&#34;off&#34;)
        if show_title:
            if isinstance(image, CellImage):
                t = &#34;{} (r: {:d}, c: {:d})&#34;.format(
                    str(image.path.name), image.row, image.col
                )
            elif image.path is not None:
                t = str(image.path.name)
            else:
                t = &#34;&#34;

            if len(t) &gt; max_title_length:
                l1 = max_title_length // 2 - 2
                l2 = max_title_length - l1 - 2
                t = t[:l1] + &#34;..&#34; + t[len(t) - l2 :]

            plt.title(t)

    register_show_plugin(axis_options, -200)


class _Base:

    T = TypeVar(&#34;T&#34;)

    @classmethod
    def from_other(
        cls: Type[T], other: T, drop_meta_types: List[Type] = None, **kwargs
    ) -&gt; T:
        &#34;&#34;&#34;Create a new image by partially overwriting the properties of another

        Args:
            other (Image): The other image
            drop_meta_types (List[Type]): Drop any meta attributes that are insteanceof these types
            **kwargs: Arguments that should be overwritten
        &#34;&#34;&#34;
        required = inspect.getfullargspec(cls.__init__)[0]

        if &#34;meta&#34; in kwargs.keys() and isinstance(kwargs[&#34;meta&#34;], dict):
            kwargs[&#34;meta&#34;] = pd.Series(kwargs[&#34;meta&#34;])

        other_args = dict()
        for name in required:
            if name == &#34;meta&#34; and &#34;meta&#34; in kwargs.keys():
                # joint meta dictionaries
                tmp = copy.copy(other._meta)
                if drop_meta_types is not None:
                    tmp = pd.Series(
                        {
                            k: v
                            for k, v in tmp.items()
                            if not np.any([isinstance(v, x) for x in drop_meta_types])
                        }
                    )
                kwargs[&#34;meta&#34;] = kwargs[&#34;meta&#34;].combine_first(tmp)

            if name not in kwargs.keys() and name != &#34;self&#34;:

                # first, try public property, then private property, then meta attribute
                if name == &#34;data&#34;:
                    other_args[name] = other._data
                elif hasattr(other, name):
                    other_args[name] = getattr(other, name)
                elif hasattr(other, &#34;_&#34; + name):
                    other_args[name] = getattr(other, &#34;_&#34; + name)
                elif isinstance(other, Image) and other.has_meta(name):
                    other_args[name] = other.get_meta(name)

                if name == &#34;meta&#34; and drop_meta_types is not None:
                    other_args[name] = {
                        k: v
                        for k, v in other_args[name].items()
                        if not np.any([isinstance(v, x) for x in drop_meta_types])
                    }

        return cls(**kwargs, **other_args)

    def from_self(self: T, drop_meta_types: List[Type] = None, **kwargs) -&gt; T:
        return type(self).from_other(self, drop_meta_types=drop_meta_types, **kwargs)


class Image(_Base):
    &#34;&#34;&#34;A general image&#34;&#34;&#34;

    @staticmethod
    def _map_numpy_dtype(dtype):
        if dtype == np.float32 or dtype == np.float64:
            return DType.FLOAT
        elif dtype == np.uint16 or dtype == np.uint32 or dtype == np.uint64:
            return DType.UNSIGNED_INT
        elif dtype == np.uint8:
            return DType.UNSIGNED_BYTE
        elif (
            dtype == np.int8
            or dtype == np.int16
            or dtype == np.int32
            or dtype == np.int64
        ):
            return DType.INT

    @staticmethod
    def _unify_dtypes(array):
        if (
            Image._map_numpy_dtype(array.dtype) == DType.UNSIGNED_INT
            and array.dtype != DTYPE_UNSIGNED_INT
        ):
            if (
                array.max() &gt; np.iinfo(DTYPE_UNSIGNED_INT).max
                or array.min() &lt; np.iinfo(DTYPE_UNSIGNED_INT).min
            ):
                raise RuntimeError(
                    &#34;Datatype conversion to {} failed, since original data exceeds dtype limits.&#34;.format(
                        DTYPE_UNSIGNED_INT
                    )
                )
            return array.astype(DTYPE_UNSIGNED_INT)
        if (
            Image._map_numpy_dtype(array.dtype) == DType.INT
            and array.dtype != DTYPE_INT
        ):
            if (
                array.max() &gt; np.iinfo(DTYPE_INT).max
                or array.min() &lt; np.iinfo(DTYPE_INT).min
            ):
                raise RuntimeError(
                    &#34;Datatype conversion to {} failed, since original data exceeds dtype limits.&#34;.format(
                        DTYPE_INT
                    )
                )
            return array.astype(DTYPE_INT)
        if (
            Image._map_numpy_dtype(array.dtype) == DType.FLOAT
            and array.dtype != DTYPE_FLOAT
        ):
            return array.astype(DTYPE_FLOAT)

        # default
        return array

    class LazyData:
        @classmethod
        @lru_cache(maxsize=SEQUENCE_MAX_CACHE_SIZE, typed=True)
        def _load(
            cls,
            load_fn: Callable[[], np.ndarray],
            checks: Tuple[Callable[[np.ndarray], np.ndarray]],
        ) -&gt; np.ndarray:
            data = load_fn()

            # perform data checks/conversions
            for check in checks:
                data = check(data)

            # make it immutable
            data.setflags(write=False)

            return data

        def __init__(self, load_fn: Callable[[], np.ndarray]):
            self._load_fn = load_fn
            self._checks: List[Callable[[np.ndarray], np.ndarray]] = list()

        def __getattr__(self, name: str):
            # forward to numpy
            data = self._load(self._load_fn, tuple(self._checks))
            return getattr(data, name)

        def __getitem__(self, s):
            data = self._load(self._load_fn, tuple(self._checks))
            return data[s]

        def push_check(self, fn: Callable[[np.ndarray], np.ndarray]):
            self._checks.append(fn)

        def load(self) -&gt; np.ndarray:
            return self._load(self._load_fn, tuple(self._checks))

    def __init__(
        self,
        data: np.ndarray,
        path: Path = None,
        modality: Modality = None,
        meta: Union[Dict[str, Any], pd.Series] = None,
    ):
        &#34;&#34;&#34;Create a new image. All non-float images as automatically converted to uint.

        Args:
            data (np.ndarray): The image data
            path (Path): Path to the image
            modality (Modality): The imaging modality
            meta (Dict[str, Any]): Meta attributes of this image
        &#34;&#34;&#34;
        self._data = data
        self._meta = (
            meta
            if isinstance(meta, pd.Series)
            else pd.Series(meta)
            if meta is not None
            else pd.Series()
        )
        self._meta[&#34;modality&#34;] = modality
        self._meta[&#34;path&#34;] = path.absolute() if path is not None else None

        if isinstance(data, np.ndarray):
            self._data = Image._unify_dtypes(self._data)
            self._data.setflags(write=False)
        else:
            self._data.push_check(Image._unify_dtypes)

    def show(self, **kwargs):
        &#34;&#34;&#34;Show this image&#34;&#34;&#34;
        _invoke_show_plugins(self, **kwargs)

    _T = TypeVar(&#34;T&#34;)

    def as_type(self: _T, dtype: DType) -&gt; _T:
        if dtype == DType.FLOAT:
            return self.from_self(data=img_as_float(self._data))
        elif dtype == DType.UNSIGNED_INT:
            return self.from_self(data=img_as_uint(self._data))
        elif dtype == DType.INT:
            return self.from_self(data=img_as_int(self._data))

    def __add__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        return self.from_self(data=self._data + other._data)

    def __sub__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        if self.dtype == DType.UNSIGNED_INT:
            res = self._data.astype(DTYPE_INT) - other._data.astype(DTYPE_INT)
            iinfo = np.iinfo(DTYPE_UNSIGNED_INT)
            res = np.clip(res, 0, iinfo.max)
            return self.from_self(data=res)
        else:
            return self.from_self(data=self._data - other._data)

    def __mul__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        return self.from_self(data=self._data * other._data)

    def __truediv__(self: _T, other: _T) -&gt; _T:
        if self.dtype != DType.FLOAT or other.dtype != DType.FLOAT:
            raise RuntimeError(&#34;Images must be of type float&#34;)
        return self.from_self(data=self._data / other._data)

    def __floordiv__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        return self.from_self(data=self._data // other._data)

    def __mod__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        return self.from_self(data=self._data % other._data)

    def __pow__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        return self.from_self(data=self._data ** other._data)

    def __deepcopy__(self: _T, memo) -&gt; _T:
        # let behavior be determined by overridden attributes
        return type(self).from_other(self)

    @property
    def data(self) -&gt; np.ndarray:
        &#34;&#34;&#34;The underlying image data&#34;&#34;&#34;
        if isinstance(self._data, Image.LazyData):
            v = self._data.load()
        else:
            v = self._data.view()
        return v

    @property
    def path(self) -&gt; Path:
        &#34;&#34;&#34;Path to the original image&#34;&#34;&#34;
        return self.get_meta(&#34;path&#34;)

    @property
    def dtype(self) -&gt; DType:
        &#34;&#34;&#34;Datatype of the image&#34;&#34;&#34;
        return Image._map_numpy_dtype(self._data.dtype)

    @property
    def shape(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Shape of the image&#34;&#34;&#34;
        return copy.deepcopy(self.data.shape)

    @property
    def modality(self) -&gt; Modality:
        &#34;&#34;&#34;The imaging modality&#34;&#34;&#34;
        return self.get_meta(&#34;modality&#34;)

    @property
    def lazy(self) -&gt; bool:
        &#34;&#34;&#34;Check, if this is lazy loaded&#34;&#34;&#34;
        return isinstance(self._data, Image.LazyData)

    def get_meta(self, key: str) -&gt; Any:
        &#34;&#34;&#34;Access a meta attribute&#34;&#34;&#34;
        if isinstance(self._meta[key], np.ndarray):
            v = self._meta[key].view()
            v.setflags(write=False)
            return v
        else:
            return copy.copy(self._meta[key])

    def has_meta(self, key: str) -&gt; bool:
        &#34;&#34;&#34;Check if a meta attribute is set&#34;&#34;&#34;
        return key in self._meta.index

    def list_meta(self) -&gt; List[str]:
        &#34;&#34;&#34;List avaliable meta keys&#34;&#34;&#34;
        return list(self._meta.index)

    def meta_from_path(
        self,
        pattern: str,
        key: str,
        target_type: Type,
        group_n: int = 0,
        transform: Callable[[Any], Any] = None,
    ) -&gt; Image:
        &#34;&#34;&#34;Extract meta information from path. The group_n&#39;th matching group
        from pattern is used as meta value

        Args:
            pattern (str): Regular expression used to parse meta
            key (str): Key of the meta attribute
            target_type (Type): Result is converted to this datatype
            group_n (int): Index of matching group
            transform (Callable[[Any], Any]): Optional function that is applied on the value
                before datatype conversion

        Returns:
            image (Image): Resulting Image
        &#34;&#34;&#34;
        s = str(self.path.absolute())
        res = re.search(pattern, s)
        v = res.group(group_n)
        if transform is not None:
            v = transform(v)
        v = target_type(v)
        return self.from_self(meta={key: v})

    def meta_from_fn(self, fn: Callable[[Image], Dict[str, Any]]) -&gt; Image:
        &#34;&#34;&#34;Extract meta data using given callable

        Args:
            fn (Callable[[Image], Dict[str, Any]]): Function used to extract meta data
        
        Returns
            image (Image): Resulting Image
        &#34;&#34;&#34;
        return self.from_other(self, meta=fn(self))

    def _meta_to_pandas(self) -&gt; pd.Series:
        &#34;&#34;&#34;Convert (compatible) meta data to pandas series&#34;&#34;&#34;
        return self._meta

    def meta_to_pandas(self) -&gt; pd.Series:
        &#34;&#34;&#34;Convert (compatible) meta data to pandas series&#34;&#34;&#34;
        return copy.deepcopy(self._meta_to_pandas())


class ImageSequence(_Base):
    &#34;&#34;&#34;An immutable sequence of images, allowing for access to single images as well as analysis of the sequence&#34;&#34;&#34;

    def _show(self, imgs: List[Image], cols: int, *args, **kwargs):
        N = len(imgs)
        rows = math.ceil(N / cols)

        # adjust the figure size
        if self.shape is not None:
            aspect = self.shape[0] / self.shape[1]
        else:
            aspect = 1.0
        plt.figure(figsize=(6 * cols, 6 * rows * aspect))

        for i, img in enumerate(imgs):
            plt.subplot(rows, cols, i + 1)
            img.show(*args, **kwargs)

    class _PandasHandler:
        def __init__(self, parent: ImageSequence):
            self._parent = parent
            pass

        class _Sub:
            def _result(self, pandas_result):
                if isinstance(pandas_result, pd.DataFrame):
                    idx = pandas_result.index.to_list()
                    result = [self._parent._images[i] for i in idx]
                    seq = type(self._parent).from_other(self._parent, images=result)
                    seq._meta_df = pandas_result.reset_index(drop=True)
                    return seq
                elif isinstance(pandas_result, pd.Series):
                    idx = pandas_result.name
                    return self._parent[idx]

            def __init__(self, parent: ImageSequence, attr):
                self._parent = parent
                self._attr = attr

            def __call__(self, *argv, **kwargs):
                pandas_result = self._attr(*argv, **kwargs)
                return self._result(pandas_result)

            def __getitem__(self, arg):
                pandas_result = self._attr[arg]
                return self._result(pandas_result)

        def __getattr__(self, name):
            attr = getattr(self._parent.meta_to_pandas(), name)
            return self._Sub(self._parent, attr)

    def __init__(
        self,
        images: List[Image],
        same_camera: bool = False,
        allow_different_dtypes=False,
    ):
        &#34;&#34;&#34;Initialize a module image sequence
        
        Args:
            images (List[Image]): The list of images
            came_camera (bool): Indicates, if all images are from the same camera and hence share the same intrinsic parameters
            allow_different_dtypes (bool): Allow images to have different datatypes?
        &#34;&#34;&#34;

        self._images = images
        self._same_camera = same_camera
        self._allow_different_dtypes = allow_different_dtypes
        self._meta_df = None
        if len(self.images) == 0:
            logging.error(&#34;Creation of an empty sequence is not supported&#34;)
            exit()

        # check that all have the same modality, dimension, dtype and module configuration
        shape = self.images[0].shape
        dtype = self.images[0].dtype
        modality = self.images[0].modality
        # for img in self.images:
        #    if img.dtype != dtype and not allow_different_dtypes:
        #        logging.error(
        #            &#39;Cannot create sequence from mixed dtypes. Consider using the &#34;allow_different_dtypes&#34; argument, when reading images.&#39;
        #        )
        #        exit()
        #    if img.shape != shape and same_camera:
        #        logging.error(
        #            &#39;Cannot create sequence from mixed shapes. Consider using the &#34;same_camera&#34; argument, when reading images.&#39;
        #        )
        #        exit()
        #    if img.modality != modality:
        #        logging.error(&#34;Cannot create a sequence from mixed modalities.&#34;)
        #        exit()

        # namespace for accessing pandas methods
        self.pandas = self._PandasHandler(self)

    def head(self, N: int = 4, cols: int = 2, *args, **kwargs):
        &#34;&#34;&#34;Show the first N images

        Args:
            N (int): Number of images to show
            cols (int): How many images to show in a column
        &#34;&#34;&#34;
        self._show(self.images[:N], cols, *args, **kwargs)

    def tail(self, N: int = 4, cols: int = 2, *args, **kwargs):
        &#34;&#34;&#34;Show the last N images

        Args:
            N (int): Number of images to show
            cols (int): How many images to show in a column
        &#34;&#34;&#34;
        self._show(self.images[-N:], cols, *args, **kwargs)

    _T = TypeVar(&#34;T&#34;)

    def apply(
        self, fn: Callable[[Image], Image], *argv, progress_bar: bool = True, **kwargs
    ) -&gt; ImageSequence:
        &#34;&#34;&#34;Apply the given callable on every image. Returns a copy of the
        original sequence

        Args:
            fn (Callable[[Image], Image]): Callable that receives and returns an Image
            progress_bar (bool): Show progress bar?
        
        Returns:
            sequence (ImageSequence): The copy with modified images
        &#34;&#34;&#34;
        result = []
        p = tqdm if progress_bar else lambda x: x
        for img in p(self._images):
            result.append(fn(img, *argv, **kwargs))
        return self.from_self(images=result)

    def apply_image_data(
        self: _T,
        fn: Callable[[np.ndarray], np.ndarray],
        *argv,
        progress_bar: bool = True,
        **kwargs
    ) -&gt; _T:
        &#34;&#34;&#34;Apply the given callable on every image data. Returns a copy of the
        original sequence with modified data

        Args:
            fn (Callable[[np.ndarray], np.ndarray]): Callable that receives a np.ndarray
                and returns a np.ndarray. Note that the argument is immutable.
            progress_bar (bool): Show progress bar?
        
        Returns:
            sequence (ImageSequence): The copy with modified data
        &#34;&#34;&#34;
        result = []
        p = tqdm if progress_bar else lambda x: x
        for img in p(self._images):
            data = img.data
            res = fn(data, *argv, **kwargs)
            result.append(type(img).from_other(img, data=res))
        return self.from_self(images=result)

    def meta_from_path(
        self,
        pattern: str,
        key: str,
        target_type: Type,
        group_n: int = 1,
        transform: Callable[[Any], Any] = None,
    ) -&gt; ImageSequence:
        &#34;&#34;&#34;Extract meta information from path of individual aimges. The group_n&#39;th matching group
        from pattern is used as meta value

        Args:
            pattern (str): Regular expression used to parse meta
            key (str): Key of the meta attribute
            target_type (Type): Result is converted to this datatype
            group_n (int): Index of matching group
            transform (Callable[[Any], Any]): Optional function that is applied on the value
                before datatype conversion

        Returns:
            images (ImageSequence): Resulting ImageSequence
        &#34;&#34;&#34;
        result = []
        for img in self._images:
            result.append(
                img.meta_from_path(
                    pattern=pattern,
                    key=key,
                    target_type=target_type,
                    group_n=group_n,
                    transform=transform,
                )
            )
        return self.from_self(images=result)

    def meta_from_fn(
        self, fn: Callable[[Image], Dict[str, Any]], **kwargs
    ) -&gt; ImageSequence:
        &#34;&#34;&#34;Extract meta information using given function

        Args:
            fn (Callable[[Image], Dict[str, Any]]): Function that is applied on every element of the sequence
        &#34;&#34;&#34;
        return self.apply(fn=lambda x: x.meta_from_fn(fn), **kwargs)

    def meta_to_pandas(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Convert meta from images to pandas DataFrame&#34;&#34;&#34;
        if self._meta_df is None:
            series = [img._meta_to_pandas() for img in self._images]
            self._meta_df = pd.DataFrame(data=series)
            self._meta_df = self._meta_df.astype(
                {&#34;modality&#34;: str}
            )  # allow for easy comparison
        return self._meta_df.copy()  # pd.DataFrame has no writable flag :(

    def as_type(self: _T, dtype: DType) -&gt; _T:
        &#34;&#34;&#34;Convert sequence to specified dtype&#34;&#34;&#34;
        result = [img.as_type(dtype) for img in self._images]
        return self.from_self(images=result)

    def __add__(self: _T, other: _T) -&gt; _T:
        res = [x + y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __sub__(self: _T, other: _T) -&gt; _T:
        res = [x - y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __mul__(self: _T, other: _T) -&gt; _T:
        res = [x * y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __truediv__(self: _T, other: _T) -&gt; _T:
        res = [x / y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __floordiv__(self: _T, other: _T) -&gt; _T:
        res = [x // y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __mod__(self: _T, other: _T) -&gt; _T:
        res = [x % y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __pow__(self: _T, other: _T) -&gt; _T:
        res = [x ** y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    @property
    def images(self) -&gt; List[Image]:
        &#34;&#34;&#34;Access the list of images&#34;&#34;&#34;
        return self._images

    @property
    def dtype(self) -&gt; DType:
        &#34;&#34;&#34;Access the image datatype&#34;&#34;&#34;
        return self.images[0].dtype if not self._allow_different_dtypes else None

    @property
    def shape(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Access the image shape&#34;&#34;&#34;
        return self.images[0].shape if self._same_camera else None

    @property
    def modality(self) -&gt; Modality:
        &#34;&#34;&#34;Access the imaging modaility&#34;&#34;&#34;
        return self.images[0].modality

    @property
    def same_camera(self) -&gt; bool:
        &#34;&#34;&#34;Indicate, if the images originate from the same camera&#34;&#34;&#34;
        return self._same_camera

    def __len__(self) -&gt; int:
        return len(self.images)

    def __getitem__(self, i: int) -&gt; Image:
        return self.images[i]


ImageOrSequence = Union[Image, ImageSequence]


class CellImage(Image):
    &#34;&#34;&#34;An image of a solar cell with additional meta data&#34;&#34;&#34;

    def __init__(
        self,
        data: np.ndarray,
        modality: Modality,
        row: int,
        col: int,
        path: Path = None,
        meta: Dict[str, Any] = None,
    ):
        &#34;&#34;&#34;Initialize a cell image

        Args:
            data (np.ndarray): The image data
            modality (Modality): The imaging modality
            path (Path): Path to the image
            row (int): Row index (zero-based)
            col (int): Cell index (zero-based)
            meta (Dict[str, Any]): Meta data
        &#34;&#34;&#34;

        super().__init__(data, path=path, modality=modality, meta=meta)
        self._meta[&#34;row&#34;] = row
        self._meta[&#34;col&#34;] = col

    @property
    def row(self) -&gt; int:
        &#34;&#34;&#34;0-based row index of the cell in the original module&#34;&#34;&#34;
        return self.get_meta(&#34;row&#34;)

    @property
    def col(self) -&gt; int:
        &#34;&#34;&#34;0-based column index of the cell in the original module&#34;&#34;&#34;
        return self.get_meta(&#34;col&#34;)

    @property
    def path(self) -&gt; Path:
        &#34;&#34;&#34;Get this images path&#34;&#34;&#34;
        p = super().path
        return Path(
            &#34;{}_row{:02d}_col{:02d}{}&#34;.format(p.stem, self.row, self.col, p.suffix)
        )

    def show(self, *argv, **kwargs):
        &#34;&#34;&#34;Show this image&#34;&#34;&#34;
        super().show(*argv, **kwargs)


class CellImageSequence(ImageSequence):
    &#34;&#34;&#34;An immutable sequence of cell images, allowing for access to single images as well as analysis of the sequence&#34;&#34;&#34;

    def __init__(self, images: List[CellImage]):
        &#34;&#34;&#34;Initialize a module image sequence
        
        Args:
            images (List[CellImage]): The list of images
        &#34;&#34;&#34;

        super().__init__(images, False)


class ModuleImage(Image):
    &#34;&#34;&#34;An image of a solar module with additional meta data&#34;&#34;&#34;

    def __init__(
        self,
        data: np.ndarray,
        modality: Modality,
        path: Path = None,
        cols: int = None,
        rows: int = None,
        meta: dict = None,
    ):
        &#34;&#34;&#34;Initialize a module image

        Args:
            data (np.ndarray): The image data
            modality (Modality): The imaging modality
            path (Path): Path to the image
            cols (int): Number of cells in a column
            rows (int): Number of cells in a row
        &#34;&#34;&#34;

        super().__init__(data, path, modality, meta)
        self._meta[&#34;cols&#34;] = cols
        self._meta[&#34;rows&#34;] = rows

    def grid(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Create a grid of corners according to the module geometry
        
        Returns:
            grid: (cols*rows, 2)-array of coordinates on a regular grid
        &#34;&#34;&#34;

        if self.cols is not None and self.rows is not None:
            x, y = np.mgrid[0 : self.cols + 1 : 1, 0 : self.rows + 1 : 1]
            grid = np.stack([x.flatten(), y.flatten()], axis=1)
            return grid
        else:
            logging.error(&#34;Module geometry is not initialized&#34;)
            exit()

    @property
    def cols(self):
        &#34;&#34;&#34;Number of cell-columns&#34;&#34;&#34;
        return self.get_meta(&#34;cols&#34;)

    @property
    def rows(self):
        &#34;&#34;&#34;Number of row-columns&#34;&#34;&#34;
        return self.get_meta(&#34;rows&#34;)


class PartialModuleImage(ModuleImage):
    &#34;&#34;&#34;An image of a solar module with additional meta data&#34;&#34;&#34;

    def __init__(
        self,
        data: np.ndarray,
        modality: Modality,
        path: Path = None,
        cols: int = None,
        rows: int = None,
        first_col: int = None,
        first_row: int = None,
        meta: dict = None,
    ):
        &#34;&#34;&#34;Initialize a module image

        Args:
            data (np.ndarray): The image data
            modality (Modality): The imaging modality
            path (Path): Path to the image
            cols (int): Number of completely visible cells in a column
            rows (int): Number of completely visible cells in a row
            first_col (int): Index of the first complete column shown
            first_row (int): Index of the first complete row shown
        &#34;&#34;&#34;

        super().__init__(data, modality, path, cols, rows, meta)

        self._meta[&#34;first_col&#34;] = first_col
        self._meta[&#34;first_row&#34;] = first_row

    def grid(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Create a grid of corners according to the module geometry
        
        Returns:
            grid: (cols*rows, 2)-array of coordinates on a regular grid
        &#34;&#34;&#34;

        if self.cols is not None and self.rows is not None:
            x, y = np.mgrid[0 : self.cols + 1 : 1, 0 : self.rows + 1 : 1]
            x += self.first_col
            y += self.first_row
            grid = np.stack([x.flatten(), y.flatten()], axis=1)
            return grid
        else:
            logging.error(&#34;Module geometry is not initialized&#34;)
            exit()

    @property
    def first_col(self) -&gt; Optional[int]:
        if self.has_meta(&#34;first_col&#34;):
            return self.get_meta(&#34;first_col&#34;)
        else:
            return None

    @property
    def first_row(self) -&gt; Optional[int]:
        if self.has_meta(&#34;first_row&#34;):
            return self.get_meta(&#34;first_row&#34;)
        else:
            return None


ModuleOrPartialModuleImage = Union[ModuleImage, PartialModuleImage]


class ModuleImageSequence(ImageSequence):
    &#34;&#34;&#34;An immutable sequence of module images, allowing for access to single images as well as analysis of the sequence&#34;&#34;&#34;

    def __init__(
        self,
        images: List[ModuleOrPartialModuleImage],
        same_camera: bool = False,
        allow_different_dtypes=False,
    ):
        &#34;&#34;&#34;Initialize a module image sequence
        
        Args:
            images (List[ModuleImage]): The list of images
            same_camera (bool): Indicates if all images are from the same camera
            allow_different_dtypes (bool): Allow images to have different datatypes?
        &#34;&#34;&#34;

        cols = images[0].cols
        rows = images[0].rows
        for img in images:
            if img.cols != cols:
                logging.error(
                    &#34;Cannot create sequence from different module configurations&#34;
                )
                exit()
            if img.rows != rows:
                logging.error(
                    &#34;Cannot create sequence from different module configurations&#34;
                )
                exit()

        super().__init__(images, same_camera, allow_different_dtypes)


ModuleImageOrSequence = Union[
    ModuleImageSequence, ModuleImage, PartialModuleImage, Image
]


def _sequence(*args):
    &#34;&#34;&#34;Assure that the first argument is a sequence and handle the first return value accordingly&#34;&#34;&#34;

    def decorator_sequence(func):
        @wraps(func)
        def wrapper_sequence(*args, **kwargs):
            if not isinstance(args[0], ImageSequence):
                args = list(args)
                args[0] = (
                    ModuleImageSequence([args[0]], same_camera=False)
                    if type(args[0]) == ModuleImage
                    else ImageSequence([args[0]], same_camera=False)
                )
                unwrap = True
            else:
                unwrap = False
            res = func(*tuple(args), **kwargs)
            if unwrap and not disable_unwrap:
                if isinstance(res, tuple) and isinstance(res[0], ImageSequence):
                    res[0] = res[0].images[0]
                elif isinstance(res, ImageSequence):
                    res = res.images[0]
            return res

        return wrapper_sequence

    if len(args) == 1 and callable(args[0]):
        disable_unwrap = False
        return decorator_sequence(args[0])
    else:
        disable_unwrap = args[0] if len(args) == 1 else False
        return decorator_sequence</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pvinspect.data.image.EL_IMAGE"><code class="name">var <span class="ident">EL_IMAGE</span></code></dt>
<dd>
<div class="desc"><p>Indicate an electroluminescense (EL) image</p></div>
</dd>
<dt id="pvinspect.data.image.PL_IMAGE"><code class="name">var <span class="ident">PL_IMAGE</span></code></dt>
<dd>
<div class="desc"><p>Indicate a photoluminescense (PL) image</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pvinspect.data.image.register_show_plugin"><code class="name flex">
<span>def <span class="ident">register_show_plugin</span></span>(<span>callable, priority: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a new plugin that is called on every .show()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>callable</code></strong></dt>
<dd>Callable that receives the image as a first argument and variable arguments to .show() next</dd>
<dt><strong><code>priority</code></strong> :&ensp;<code>int</code></dt>
<dd>Plugins are invoked in the order of increasing priority (highest priority is invoked
last and hence appears on top)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_show_plugin(callable, priority: int = 0):
    &#34;&#34;&#34;Register a new plugin that is called on every .show()

    Args:
        callable: Callable that receives the image as a first argument and variable arguments to .show() next
        priority (int): Plugins are invoked in the order of increasing priority (highest priority is invoked
            last and hence appears on top)
    &#34;&#34;&#34;
    this.show_plugins.append((priority, callable))
    this.show_plugins = sorted(this.show_plugins, key=lambda x: x[0])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pvinspect.data.image.CellImage"><code class="flex name class">
<span>class <span class="ident">CellImage</span></span>
<span>(</span><span>data: np.ndarray, modality: <a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a>, row: int, col: int, path: Path = None, meta: Dict[str, Any] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>An image of a solar cell with additional meta data</p>
<p>Initialize a cell image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The image data</dd>
<dt><strong><code>modality</code></strong> :&ensp;<code><a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a></code></dt>
<dd>The imaging modality</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>Path to the image</dd>
<dt><strong><code>row</code></strong> :&ensp;<code>int</code></dt>
<dd>Row index (zero-based)</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>int</code></dt>
<dd>Cell index (zero-based)</dd>
<dt><strong><code>meta</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Meta data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CellImage(Image):
    &#34;&#34;&#34;An image of a solar cell with additional meta data&#34;&#34;&#34;

    def __init__(
        self,
        data: np.ndarray,
        modality: Modality,
        row: int,
        col: int,
        path: Path = None,
        meta: Dict[str, Any] = None,
    ):
        &#34;&#34;&#34;Initialize a cell image

        Args:
            data (np.ndarray): The image data
            modality (Modality): The imaging modality
            path (Path): Path to the image
            row (int): Row index (zero-based)
            col (int): Cell index (zero-based)
            meta (Dict[str, Any]): Meta data
        &#34;&#34;&#34;

        super().__init__(data, path=path, modality=modality, meta=meta)
        self._meta[&#34;row&#34;] = row
        self._meta[&#34;col&#34;] = col

    @property
    def row(self) -&gt; int:
        &#34;&#34;&#34;0-based row index of the cell in the original module&#34;&#34;&#34;
        return self.get_meta(&#34;row&#34;)

    @property
    def col(self) -&gt; int:
        &#34;&#34;&#34;0-based column index of the cell in the original module&#34;&#34;&#34;
        return self.get_meta(&#34;col&#34;)

    @property
    def path(self) -&gt; Path:
        &#34;&#34;&#34;Get this images path&#34;&#34;&#34;
        p = super().path
        return Path(
            &#34;{}_row{:02d}_col{:02d}{}&#34;.format(p.stem, self.row, self.col, p.suffix)
        )

    def show(self, *argv, **kwargs):
        &#34;&#34;&#34;Show this image&#34;&#34;&#34;
        super().show(*argv, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a></li>
<li>pvinspect.data.image._Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pvinspect.data.image.CellImage.col"><code class="name">var <span class="ident">col</span> : int</code></dt>
<dd>
<div class="desc"><p>0-based column index of the cell in the original module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def col(self) -&gt; int:
    &#34;&#34;&#34;0-based column index of the cell in the original module&#34;&#34;&#34;
    return self.get_meta(&#34;col&#34;)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.CellImage.path"><code class="name">var <span class="ident">path</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"><p>Get this images path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self) -&gt; Path:
    &#34;&#34;&#34;Get this images path&#34;&#34;&#34;
    p = super().path
    return Path(
        &#34;{}_row{:02d}_col{:02d}{}&#34;.format(p.stem, self.row, self.col, p.suffix)
    )</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.CellImage.row"><code class="name">var <span class="ident">row</span> : int</code></dt>
<dd>
<div class="desc"><p>0-based row index of the cell in the original module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def row(self) -&gt; int:
    &#34;&#34;&#34;0-based row index of the cell in the original module&#34;&#34;&#34;
    return self.get_meta(&#34;row&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a></b></code>:
<ul class="hlist">
<li><code><a title="pvinspect.data.image.Image.data" href="#pvinspect.data.image.Image.data">data</a></code></li>
<li><code><a title="pvinspect.data.image.Image.dtype" href="#pvinspect.data.image.Image.dtype">dtype</a></code></li>
<li><code><a title="pvinspect.data.image.Image.get_meta" href="#pvinspect.data.image.Image.get_meta">get_meta</a></code></li>
<li><code><a title="pvinspect.data.image.Image.has_meta" href="#pvinspect.data.image.Image.has_meta">has_meta</a></code></li>
<li><code><a title="pvinspect.data.image.Image.lazy" href="#pvinspect.data.image.Image.lazy">lazy</a></code></li>
<li><code><a title="pvinspect.data.image.Image.list_meta" href="#pvinspect.data.image.Image.list_meta">list_meta</a></code></li>
<li><code><a title="pvinspect.data.image.Image.meta_from_fn" href="#pvinspect.data.image.Image.meta_from_fn">meta_from_fn</a></code></li>
<li><code><a title="pvinspect.data.image.Image.meta_from_path" href="#pvinspect.data.image.Image.meta_from_path">meta_from_path</a></code></li>
<li><code><a title="pvinspect.data.image.Image.meta_to_pandas" href="#pvinspect.data.image.Image.meta_to_pandas">meta_to_pandas</a></code></li>
<li><code><a title="pvinspect.data.image.Image.modality" href="#pvinspect.data.image.Image.modality">modality</a></code></li>
<li><code><a title="pvinspect.data.image.Image.shape" href="#pvinspect.data.image.Image.shape">shape</a></code></li>
<li><code><a title="pvinspect.data.image.Image.show" href="#pvinspect.data.image.Image.show">show</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pvinspect.data.image.CellImageSequence"><code class="flex name class">
<span>class <span class="ident">CellImageSequence</span></span>
<span>(</span><span>images: List[<a title="pvinspect.data.image.CellImage" href="#pvinspect.data.image.CellImage">CellImage</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>An immutable sequence of cell images, allowing for access to single images as well as analysis of the sequence</p>
<p>Initialize a module image sequence</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>List[<a title="pvinspect.data.image.CellImage" href="#pvinspect.data.image.CellImage">CellImage</a>]</code></dt>
<dd>The list of images</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CellImageSequence(ImageSequence):
    &#34;&#34;&#34;An immutable sequence of cell images, allowing for access to single images as well as analysis of the sequence&#34;&#34;&#34;

    def __init__(self, images: List[CellImage]):
        &#34;&#34;&#34;Initialize a module image sequence
        
        Args:
            images (List[CellImage]): The list of images
        &#34;&#34;&#34;

        super().__init__(images, False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pvinspect.data.image.ImageSequence" href="#pvinspect.data.image.ImageSequence">ImageSequence</a></li>
<li>pvinspect.data.image._Base</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pvinspect.data.image.ImageSequence" href="#pvinspect.data.image.ImageSequence">ImageSequence</a></b></code>:
<ul class="hlist">
<li><code><a title="pvinspect.data.image.ImageSequence.apply" href="#pvinspect.data.image.ImageSequence.apply">apply</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.apply_image_data" href="#pvinspect.data.image.ImageSequence.apply_image_data">apply_image_data</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.as_type" href="#pvinspect.data.image.ImageSequence.as_type">as_type</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.dtype" href="#pvinspect.data.image.ImageSequence.dtype">dtype</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.head" href="#pvinspect.data.image.ImageSequence.head">head</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.images" href="#pvinspect.data.image.ImageSequence.images">images</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.meta_from_fn" href="#pvinspect.data.image.ImageSequence.meta_from_fn">meta_from_fn</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.meta_from_path" href="#pvinspect.data.image.ImageSequence.meta_from_path">meta_from_path</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.meta_to_pandas" href="#pvinspect.data.image.ImageSequence.meta_to_pandas">meta_to_pandas</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.modality" href="#pvinspect.data.image.ImageSequence.modality">modality</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.same_camera" href="#pvinspect.data.image.ImageSequence.same_camera">same_camera</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.shape" href="#pvinspect.data.image.ImageSequence.shape">shape</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.tail" href="#pvinspect.data.image.ImageSequence.tail">tail</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pvinspect.data.image.DType"><code class="flex name class">
<span>class <span class="ident">DType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DType(Enum):
    INT = 0
    UNSIGNED_INT = 1
    FLOAT = 2
    UNSIGNED_BYTE = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pvinspect.data.image.DType.FLOAT"><code class="name">var <span class="ident">FLOAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pvinspect.data.image.DType.INT"><code class="name">var <span class="ident">INT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pvinspect.data.image.DType.UNSIGNED_BYTE"><code class="name">var <span class="ident">UNSIGNED_BYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pvinspect.data.image.DType.UNSIGNED_INT"><code class="name">var <span class="ident">UNSIGNED_INT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pvinspect.data.image.Image"><code class="flex name class">
<span>class <span class="ident">Image</span></span>
<span>(</span><span>data: np.ndarray, path: Path = None, modality: <a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a> = None, meta: Union[Dict[str, Any], pd.Series] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A general image</p>
<p>Create a new image. All non-float images as automatically converted to uint.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The image data</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>Path to the image</dd>
<dt><strong><code>modality</code></strong> :&ensp;<code><a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a></code></dt>
<dd>The imaging modality</dd>
<dt><strong><code>meta</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Meta attributes of this image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Image(_Base):
    &#34;&#34;&#34;A general image&#34;&#34;&#34;

    @staticmethod
    def _map_numpy_dtype(dtype):
        if dtype == np.float32 or dtype == np.float64:
            return DType.FLOAT
        elif dtype == np.uint16 or dtype == np.uint32 or dtype == np.uint64:
            return DType.UNSIGNED_INT
        elif dtype == np.uint8:
            return DType.UNSIGNED_BYTE
        elif (
            dtype == np.int8
            or dtype == np.int16
            or dtype == np.int32
            or dtype == np.int64
        ):
            return DType.INT

    @staticmethod
    def _unify_dtypes(array):
        if (
            Image._map_numpy_dtype(array.dtype) == DType.UNSIGNED_INT
            and array.dtype != DTYPE_UNSIGNED_INT
        ):
            if (
                array.max() &gt; np.iinfo(DTYPE_UNSIGNED_INT).max
                or array.min() &lt; np.iinfo(DTYPE_UNSIGNED_INT).min
            ):
                raise RuntimeError(
                    &#34;Datatype conversion to {} failed, since original data exceeds dtype limits.&#34;.format(
                        DTYPE_UNSIGNED_INT
                    )
                )
            return array.astype(DTYPE_UNSIGNED_INT)
        if (
            Image._map_numpy_dtype(array.dtype) == DType.INT
            and array.dtype != DTYPE_INT
        ):
            if (
                array.max() &gt; np.iinfo(DTYPE_INT).max
                or array.min() &lt; np.iinfo(DTYPE_INT).min
            ):
                raise RuntimeError(
                    &#34;Datatype conversion to {} failed, since original data exceeds dtype limits.&#34;.format(
                        DTYPE_INT
                    )
                )
            return array.astype(DTYPE_INT)
        if (
            Image._map_numpy_dtype(array.dtype) == DType.FLOAT
            and array.dtype != DTYPE_FLOAT
        ):
            return array.astype(DTYPE_FLOAT)

        # default
        return array

    class LazyData:
        @classmethod
        @lru_cache(maxsize=SEQUENCE_MAX_CACHE_SIZE, typed=True)
        def _load(
            cls,
            load_fn: Callable[[], np.ndarray],
            checks: Tuple[Callable[[np.ndarray], np.ndarray]],
        ) -&gt; np.ndarray:
            data = load_fn()

            # perform data checks/conversions
            for check in checks:
                data = check(data)

            # make it immutable
            data.setflags(write=False)

            return data

        def __init__(self, load_fn: Callable[[], np.ndarray]):
            self._load_fn = load_fn
            self._checks: List[Callable[[np.ndarray], np.ndarray]] = list()

        def __getattr__(self, name: str):
            # forward to numpy
            data = self._load(self._load_fn, tuple(self._checks))
            return getattr(data, name)

        def __getitem__(self, s):
            data = self._load(self._load_fn, tuple(self._checks))
            return data[s]

        def push_check(self, fn: Callable[[np.ndarray], np.ndarray]):
            self._checks.append(fn)

        def load(self) -&gt; np.ndarray:
            return self._load(self._load_fn, tuple(self._checks))

    def __init__(
        self,
        data: np.ndarray,
        path: Path = None,
        modality: Modality = None,
        meta: Union[Dict[str, Any], pd.Series] = None,
    ):
        &#34;&#34;&#34;Create a new image. All non-float images as automatically converted to uint.

        Args:
            data (np.ndarray): The image data
            path (Path): Path to the image
            modality (Modality): The imaging modality
            meta (Dict[str, Any]): Meta attributes of this image
        &#34;&#34;&#34;
        self._data = data
        self._meta = (
            meta
            if isinstance(meta, pd.Series)
            else pd.Series(meta)
            if meta is not None
            else pd.Series()
        )
        self._meta[&#34;modality&#34;] = modality
        self._meta[&#34;path&#34;] = path.absolute() if path is not None else None

        if isinstance(data, np.ndarray):
            self._data = Image._unify_dtypes(self._data)
            self._data.setflags(write=False)
        else:
            self._data.push_check(Image._unify_dtypes)

    def show(self, **kwargs):
        &#34;&#34;&#34;Show this image&#34;&#34;&#34;
        _invoke_show_plugins(self, **kwargs)

    _T = TypeVar(&#34;T&#34;)

    def as_type(self: _T, dtype: DType) -&gt; _T:
        if dtype == DType.FLOAT:
            return self.from_self(data=img_as_float(self._data))
        elif dtype == DType.UNSIGNED_INT:
            return self.from_self(data=img_as_uint(self._data))
        elif dtype == DType.INT:
            return self.from_self(data=img_as_int(self._data))

    def __add__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        return self.from_self(data=self._data + other._data)

    def __sub__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        if self.dtype == DType.UNSIGNED_INT:
            res = self._data.astype(DTYPE_INT) - other._data.astype(DTYPE_INT)
            iinfo = np.iinfo(DTYPE_UNSIGNED_INT)
            res = np.clip(res, 0, iinfo.max)
            return self.from_self(data=res)
        else:
            return self.from_self(data=self._data - other._data)

    def __mul__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        return self.from_self(data=self._data * other._data)

    def __truediv__(self: _T, other: _T) -&gt; _T:
        if self.dtype != DType.FLOAT or other.dtype != DType.FLOAT:
            raise RuntimeError(&#34;Images must be of type float&#34;)
        return self.from_self(data=self._data / other._data)

    def __floordiv__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        return self.from_self(data=self._data // other._data)

    def __mod__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        return self.from_self(data=self._data % other._data)

    def __pow__(self: _T, other: _T) -&gt; _T:
        if self.dtype != other.dtype:
            raise RuntimeError(&#34;Images must have the same datatype&#34;)
        return self.from_self(data=self._data ** other._data)

    def __deepcopy__(self: _T, memo) -&gt; _T:
        # let behavior be determined by overridden attributes
        return type(self).from_other(self)

    @property
    def data(self) -&gt; np.ndarray:
        &#34;&#34;&#34;The underlying image data&#34;&#34;&#34;
        if isinstance(self._data, Image.LazyData):
            v = self._data.load()
        else:
            v = self._data.view()
        return v

    @property
    def path(self) -&gt; Path:
        &#34;&#34;&#34;Path to the original image&#34;&#34;&#34;
        return self.get_meta(&#34;path&#34;)

    @property
    def dtype(self) -&gt; DType:
        &#34;&#34;&#34;Datatype of the image&#34;&#34;&#34;
        return Image._map_numpy_dtype(self._data.dtype)

    @property
    def shape(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Shape of the image&#34;&#34;&#34;
        return copy.deepcopy(self.data.shape)

    @property
    def modality(self) -&gt; Modality:
        &#34;&#34;&#34;The imaging modality&#34;&#34;&#34;
        return self.get_meta(&#34;modality&#34;)

    @property
    def lazy(self) -&gt; bool:
        &#34;&#34;&#34;Check, if this is lazy loaded&#34;&#34;&#34;
        return isinstance(self._data, Image.LazyData)

    def get_meta(self, key: str) -&gt; Any:
        &#34;&#34;&#34;Access a meta attribute&#34;&#34;&#34;
        if isinstance(self._meta[key], np.ndarray):
            v = self._meta[key].view()
            v.setflags(write=False)
            return v
        else:
            return copy.copy(self._meta[key])

    def has_meta(self, key: str) -&gt; bool:
        &#34;&#34;&#34;Check if a meta attribute is set&#34;&#34;&#34;
        return key in self._meta.index

    def list_meta(self) -&gt; List[str]:
        &#34;&#34;&#34;List avaliable meta keys&#34;&#34;&#34;
        return list(self._meta.index)

    def meta_from_path(
        self,
        pattern: str,
        key: str,
        target_type: Type,
        group_n: int = 0,
        transform: Callable[[Any], Any] = None,
    ) -&gt; Image:
        &#34;&#34;&#34;Extract meta information from path. The group_n&#39;th matching group
        from pattern is used as meta value

        Args:
            pattern (str): Regular expression used to parse meta
            key (str): Key of the meta attribute
            target_type (Type): Result is converted to this datatype
            group_n (int): Index of matching group
            transform (Callable[[Any], Any]): Optional function that is applied on the value
                before datatype conversion

        Returns:
            image (Image): Resulting Image
        &#34;&#34;&#34;
        s = str(self.path.absolute())
        res = re.search(pattern, s)
        v = res.group(group_n)
        if transform is not None:
            v = transform(v)
        v = target_type(v)
        return self.from_self(meta={key: v})

    def meta_from_fn(self, fn: Callable[[Image], Dict[str, Any]]) -&gt; Image:
        &#34;&#34;&#34;Extract meta data using given callable

        Args:
            fn (Callable[[Image], Dict[str, Any]]): Function used to extract meta data
        
        Returns
            image (Image): Resulting Image
        &#34;&#34;&#34;
        return self.from_other(self, meta=fn(self))

    def _meta_to_pandas(self) -&gt; pd.Series:
        &#34;&#34;&#34;Convert (compatible) meta data to pandas series&#34;&#34;&#34;
        return self._meta

    def meta_to_pandas(self) -&gt; pd.Series:
        &#34;&#34;&#34;Convert (compatible) meta data to pandas series&#34;&#34;&#34;
        return copy.deepcopy(self._meta_to_pandas())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pvinspect.data.image._Base</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pvinspect.data.image.CellImage" href="#pvinspect.data.image.CellImage">CellImage</a></li>
<li><a title="pvinspect.data.image.ModuleImage" href="#pvinspect.data.image.ModuleImage">ModuleImage</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pvinspect.data.image.Image.LazyData"><code class="name">var <span class="ident">LazyData</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pvinspect.data.image.Image.data"><code class="name">var <span class="ident">data</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The underlying image data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; np.ndarray:
    &#34;&#34;&#34;The underlying image data&#34;&#34;&#34;
    if isinstance(self._data, Image.LazyData):
        v = self._data.load()
    else:
        v = self._data.view()
    return v</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.dtype"><code class="name">var <span class="ident">dtype</span> : <a title="pvinspect.data.image.DType" href="#pvinspect.data.image.DType">DType</a></code></dt>
<dd>
<div class="desc"><p>Datatype of the image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dtype(self) -&gt; DType:
    &#34;&#34;&#34;Datatype of the image&#34;&#34;&#34;
    return Image._map_numpy_dtype(self._data.dtype)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.lazy"><code class="name">var <span class="ident">lazy</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check, if this is lazy loaded</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lazy(self) -&gt; bool:
    &#34;&#34;&#34;Check, if this is lazy loaded&#34;&#34;&#34;
    return isinstance(self._data, Image.LazyData)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.modality"><code class="name">var <span class="ident">modality</span> : <a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a></code></dt>
<dd>
<div class="desc"><p>The imaging modality</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def modality(self) -&gt; Modality:
    &#34;&#34;&#34;The imaging modality&#34;&#34;&#34;
    return self.get_meta(&#34;modality&#34;)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.path"><code class="name">var <span class="ident">path</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"><p>Path to the original image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self) -&gt; Path:
    &#34;&#34;&#34;Path to the original image&#34;&#34;&#34;
    return self.get_meta(&#34;path&#34;)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.shape"><code class="name">var <span class="ident">shape</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Shape of the image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Shape of the image&#34;&#34;&#34;
    return copy.deepcopy(self.data.shape)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pvinspect.data.image.Image.as_type"><code class="name flex">
<span>def <span class="ident">as_type</span></span>(<span>self: _T, dtype: <a title="pvinspect.data.image.DType" href="#pvinspect.data.image.DType">DType</a>) ‑> _T</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_type(self: _T, dtype: DType) -&gt; _T:
    if dtype == DType.FLOAT:
        return self.from_self(data=img_as_float(self._data))
    elif dtype == DType.UNSIGNED_INT:
        return self.from_self(data=img_as_uint(self._data))
    elif dtype == DType.INT:
        return self.from_self(data=img_as_int(self._data))</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.get_meta"><code class="name flex">
<span>def <span class="ident">get_meta</span></span>(<span>self, key: str) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Access a meta attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_meta(self, key: str) -&gt; Any:
    &#34;&#34;&#34;Access a meta attribute&#34;&#34;&#34;
    if isinstance(self._meta[key], np.ndarray):
        v = self._meta[key].view()
        v.setflags(write=False)
        return v
    else:
        return copy.copy(self._meta[key])</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.has_meta"><code class="name flex">
<span>def <span class="ident">has_meta</span></span>(<span>self, key: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a meta attribute is set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_meta(self, key: str) -&gt; bool:
    &#34;&#34;&#34;Check if a meta attribute is set&#34;&#34;&#34;
    return key in self._meta.index</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.list_meta"><code class="name flex">
<span>def <span class="ident">list_meta</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>List avaliable meta keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_meta(self) -&gt; List[str]:
    &#34;&#34;&#34;List avaliable meta keys&#34;&#34;&#34;
    return list(self._meta.index)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.meta_from_fn"><code class="name flex">
<span>def <span class="ident">meta_from_fn</span></span>(<span>self, fn: Callable[[<a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>], Dict[str, Any]]) ‑> <a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a></span>
</code></dt>
<dd>
<div class="desc"><p>Extract meta data using given callable</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fn</code></strong> :&ensp;<code>Callable[[<a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>], Dict[str, Any]]</code></dt>
<dd>Function used to extract meta data</dd>
</dl>
<p>Returns
image (Image): Resulting Image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meta_from_fn(self, fn: Callable[[Image], Dict[str, Any]]) -&gt; Image:
    &#34;&#34;&#34;Extract meta data using given callable

    Args:
        fn (Callable[[Image], Dict[str, Any]]): Function used to extract meta data
    
    Returns
        image (Image): Resulting Image
    &#34;&#34;&#34;
    return self.from_other(self, meta=fn(self))</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.meta_from_path"><code class="name flex">
<span>def <span class="ident">meta_from_path</span></span>(<span>self, pattern: str, key: str, target_type: Type, group_n: int = 0, transform: Callable[[Any], Any] = None) ‑> <a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a></span>
</code></dt>
<dd>
<div class="desc"><p>Extract meta information from path. The group_n'th matching group
from pattern is used as meta value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>Regular expression used to parse meta</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Key of the meta attribute</dd>
<dt><strong><code>target_type</code></strong> :&ensp;<code>Type</code></dt>
<dd>Result is converted to this datatype</dd>
<dt><strong><code>group_n</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of matching group</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>Callable[[Any], Any]</code></dt>
<dd>Optional function that is applied on the value
before datatype conversion</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>image (Image): Resulting Image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meta_from_path(
    self,
    pattern: str,
    key: str,
    target_type: Type,
    group_n: int = 0,
    transform: Callable[[Any], Any] = None,
) -&gt; Image:
    &#34;&#34;&#34;Extract meta information from path. The group_n&#39;th matching group
    from pattern is used as meta value

    Args:
        pattern (str): Regular expression used to parse meta
        key (str): Key of the meta attribute
        target_type (Type): Result is converted to this datatype
        group_n (int): Index of matching group
        transform (Callable[[Any], Any]): Optional function that is applied on the value
            before datatype conversion

    Returns:
        image (Image): Resulting Image
    &#34;&#34;&#34;
    s = str(self.path.absolute())
    res = re.search(pattern, s)
    v = res.group(group_n)
    if transform is not None:
        v = transform(v)
    v = target_type(v)
    return self.from_self(meta={key: v})</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.meta_to_pandas"><code class="name flex">
<span>def <span class="ident">meta_to_pandas</span></span>(<span>self) ‑> pandas.core.series.Series</span>
</code></dt>
<dd>
<div class="desc"><p>Convert (compatible) meta data to pandas series</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meta_to_pandas(self) -&gt; pd.Series:
    &#34;&#34;&#34;Convert (compatible) meta data to pandas series&#34;&#34;&#34;
    return copy.deepcopy(self._meta_to_pandas())</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.Image.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Show this image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, **kwargs):
    &#34;&#34;&#34;Show this image&#34;&#34;&#34;
    _invoke_show_plugins(self, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pvinspect.data.image.ImageSequence"><code class="flex name class">
<span>class <span class="ident">ImageSequence</span></span>
<span>(</span><span>images: List[<a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>], same_camera: bool = False, allow_different_dtypes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>An immutable sequence of images, allowing for access to single images as well as analysis of the sequence</p>
<p>Initialize a module image sequence</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>List[<a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>]</code></dt>
<dd>The list of images</dd>
<dt><strong><code>came_camera</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates, if all images are from the same camera and hence share the same intrinsic parameters</dd>
<dt><strong><code>allow_different_dtypes</code></strong> :&ensp;<code>bool</code></dt>
<dd>Allow images to have different datatypes?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageSequence(_Base):
    &#34;&#34;&#34;An immutable sequence of images, allowing for access to single images as well as analysis of the sequence&#34;&#34;&#34;

    def _show(self, imgs: List[Image], cols: int, *args, **kwargs):
        N = len(imgs)
        rows = math.ceil(N / cols)

        # adjust the figure size
        if self.shape is not None:
            aspect = self.shape[0] / self.shape[1]
        else:
            aspect = 1.0
        plt.figure(figsize=(6 * cols, 6 * rows * aspect))

        for i, img in enumerate(imgs):
            plt.subplot(rows, cols, i + 1)
            img.show(*args, **kwargs)

    class _PandasHandler:
        def __init__(self, parent: ImageSequence):
            self._parent = parent
            pass

        class _Sub:
            def _result(self, pandas_result):
                if isinstance(pandas_result, pd.DataFrame):
                    idx = pandas_result.index.to_list()
                    result = [self._parent._images[i] for i in idx]
                    seq = type(self._parent).from_other(self._parent, images=result)
                    seq._meta_df = pandas_result.reset_index(drop=True)
                    return seq
                elif isinstance(pandas_result, pd.Series):
                    idx = pandas_result.name
                    return self._parent[idx]

            def __init__(self, parent: ImageSequence, attr):
                self._parent = parent
                self._attr = attr

            def __call__(self, *argv, **kwargs):
                pandas_result = self._attr(*argv, **kwargs)
                return self._result(pandas_result)

            def __getitem__(self, arg):
                pandas_result = self._attr[arg]
                return self._result(pandas_result)

        def __getattr__(self, name):
            attr = getattr(self._parent.meta_to_pandas(), name)
            return self._Sub(self._parent, attr)

    def __init__(
        self,
        images: List[Image],
        same_camera: bool = False,
        allow_different_dtypes=False,
    ):
        &#34;&#34;&#34;Initialize a module image sequence
        
        Args:
            images (List[Image]): The list of images
            came_camera (bool): Indicates, if all images are from the same camera and hence share the same intrinsic parameters
            allow_different_dtypes (bool): Allow images to have different datatypes?
        &#34;&#34;&#34;

        self._images = images
        self._same_camera = same_camera
        self._allow_different_dtypes = allow_different_dtypes
        self._meta_df = None
        if len(self.images) == 0:
            logging.error(&#34;Creation of an empty sequence is not supported&#34;)
            exit()

        # check that all have the same modality, dimension, dtype and module configuration
        shape = self.images[0].shape
        dtype = self.images[0].dtype
        modality = self.images[0].modality
        # for img in self.images:
        #    if img.dtype != dtype and not allow_different_dtypes:
        #        logging.error(
        #            &#39;Cannot create sequence from mixed dtypes. Consider using the &#34;allow_different_dtypes&#34; argument, when reading images.&#39;
        #        )
        #        exit()
        #    if img.shape != shape and same_camera:
        #        logging.error(
        #            &#39;Cannot create sequence from mixed shapes. Consider using the &#34;same_camera&#34; argument, when reading images.&#39;
        #        )
        #        exit()
        #    if img.modality != modality:
        #        logging.error(&#34;Cannot create a sequence from mixed modalities.&#34;)
        #        exit()

        # namespace for accessing pandas methods
        self.pandas = self._PandasHandler(self)

    def head(self, N: int = 4, cols: int = 2, *args, **kwargs):
        &#34;&#34;&#34;Show the first N images

        Args:
            N (int): Number of images to show
            cols (int): How many images to show in a column
        &#34;&#34;&#34;
        self._show(self.images[:N], cols, *args, **kwargs)

    def tail(self, N: int = 4, cols: int = 2, *args, **kwargs):
        &#34;&#34;&#34;Show the last N images

        Args:
            N (int): Number of images to show
            cols (int): How many images to show in a column
        &#34;&#34;&#34;
        self._show(self.images[-N:], cols, *args, **kwargs)

    _T = TypeVar(&#34;T&#34;)

    def apply(
        self, fn: Callable[[Image], Image], *argv, progress_bar: bool = True, **kwargs
    ) -&gt; ImageSequence:
        &#34;&#34;&#34;Apply the given callable on every image. Returns a copy of the
        original sequence

        Args:
            fn (Callable[[Image], Image]): Callable that receives and returns an Image
            progress_bar (bool): Show progress bar?
        
        Returns:
            sequence (ImageSequence): The copy with modified images
        &#34;&#34;&#34;
        result = []
        p = tqdm if progress_bar else lambda x: x
        for img in p(self._images):
            result.append(fn(img, *argv, **kwargs))
        return self.from_self(images=result)

    def apply_image_data(
        self: _T,
        fn: Callable[[np.ndarray], np.ndarray],
        *argv,
        progress_bar: bool = True,
        **kwargs
    ) -&gt; _T:
        &#34;&#34;&#34;Apply the given callable on every image data. Returns a copy of the
        original sequence with modified data

        Args:
            fn (Callable[[np.ndarray], np.ndarray]): Callable that receives a np.ndarray
                and returns a np.ndarray. Note that the argument is immutable.
            progress_bar (bool): Show progress bar?
        
        Returns:
            sequence (ImageSequence): The copy with modified data
        &#34;&#34;&#34;
        result = []
        p = tqdm if progress_bar else lambda x: x
        for img in p(self._images):
            data = img.data
            res = fn(data, *argv, **kwargs)
            result.append(type(img).from_other(img, data=res))
        return self.from_self(images=result)

    def meta_from_path(
        self,
        pattern: str,
        key: str,
        target_type: Type,
        group_n: int = 1,
        transform: Callable[[Any], Any] = None,
    ) -&gt; ImageSequence:
        &#34;&#34;&#34;Extract meta information from path of individual aimges. The group_n&#39;th matching group
        from pattern is used as meta value

        Args:
            pattern (str): Regular expression used to parse meta
            key (str): Key of the meta attribute
            target_type (Type): Result is converted to this datatype
            group_n (int): Index of matching group
            transform (Callable[[Any], Any]): Optional function that is applied on the value
                before datatype conversion

        Returns:
            images (ImageSequence): Resulting ImageSequence
        &#34;&#34;&#34;
        result = []
        for img in self._images:
            result.append(
                img.meta_from_path(
                    pattern=pattern,
                    key=key,
                    target_type=target_type,
                    group_n=group_n,
                    transform=transform,
                )
            )
        return self.from_self(images=result)

    def meta_from_fn(
        self, fn: Callable[[Image], Dict[str, Any]], **kwargs
    ) -&gt; ImageSequence:
        &#34;&#34;&#34;Extract meta information using given function

        Args:
            fn (Callable[[Image], Dict[str, Any]]): Function that is applied on every element of the sequence
        &#34;&#34;&#34;
        return self.apply(fn=lambda x: x.meta_from_fn(fn), **kwargs)

    def meta_to_pandas(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Convert meta from images to pandas DataFrame&#34;&#34;&#34;
        if self._meta_df is None:
            series = [img._meta_to_pandas() for img in self._images]
            self._meta_df = pd.DataFrame(data=series)
            self._meta_df = self._meta_df.astype(
                {&#34;modality&#34;: str}
            )  # allow for easy comparison
        return self._meta_df.copy()  # pd.DataFrame has no writable flag :(

    def as_type(self: _T, dtype: DType) -&gt; _T:
        &#34;&#34;&#34;Convert sequence to specified dtype&#34;&#34;&#34;
        result = [img.as_type(dtype) for img in self._images]
        return self.from_self(images=result)

    def __add__(self: _T, other: _T) -&gt; _T:
        res = [x + y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __sub__(self: _T, other: _T) -&gt; _T:
        res = [x - y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __mul__(self: _T, other: _T) -&gt; _T:
        res = [x * y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __truediv__(self: _T, other: _T) -&gt; _T:
        res = [x / y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __floordiv__(self: _T, other: _T) -&gt; _T:
        res = [x // y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __mod__(self: _T, other: _T) -&gt; _T:
        res = [x % y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    def __pow__(self: _T, other: _T) -&gt; _T:
        res = [x ** y for x, y in zip(self.images, other.images)]
        return self.from_self(images=res)

    @property
    def images(self) -&gt; List[Image]:
        &#34;&#34;&#34;Access the list of images&#34;&#34;&#34;
        return self._images

    @property
    def dtype(self) -&gt; DType:
        &#34;&#34;&#34;Access the image datatype&#34;&#34;&#34;
        return self.images[0].dtype if not self._allow_different_dtypes else None

    @property
    def shape(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Access the image shape&#34;&#34;&#34;
        return self.images[0].shape if self._same_camera else None

    @property
    def modality(self) -&gt; Modality:
        &#34;&#34;&#34;Access the imaging modaility&#34;&#34;&#34;
        return self.images[0].modality

    @property
    def same_camera(self) -&gt; bool:
        &#34;&#34;&#34;Indicate, if the images originate from the same camera&#34;&#34;&#34;
        return self._same_camera

    def __len__(self) -&gt; int:
        return len(self.images)

    def __getitem__(self, i: int) -&gt; Image:
        return self.images[i]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pvinspect.data.image._Base</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pvinspect.data.image.CellImageSequence" href="#pvinspect.data.image.CellImageSequence">CellImageSequence</a></li>
<li><a title="pvinspect.data.image.ModuleImageSequence" href="#pvinspect.data.image.ModuleImageSequence">ModuleImageSequence</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pvinspect.data.image.ImageSequence.dtype"><code class="name">var <span class="ident">dtype</span> : <a title="pvinspect.data.image.DType" href="#pvinspect.data.image.DType">DType</a></code></dt>
<dd>
<div class="desc"><p>Access the image datatype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dtype(self) -&gt; DType:
    &#34;&#34;&#34;Access the image datatype&#34;&#34;&#34;
    return self.images[0].dtype if not self._allow_different_dtypes else None</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.images"><code class="name">var <span class="ident">images</span> : List[<a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>]</code></dt>
<dd>
<div class="desc"><p>Access the list of images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def images(self) -&gt; List[Image]:
    &#34;&#34;&#34;Access the list of images&#34;&#34;&#34;
    return self._images</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.modality"><code class="name">var <span class="ident">modality</span> : <a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a></code></dt>
<dd>
<div class="desc"><p>Access the imaging modaility</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def modality(self) -&gt; Modality:
    &#34;&#34;&#34;Access the imaging modaility&#34;&#34;&#34;
    return self.images[0].modality</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.same_camera"><code class="name">var <span class="ident">same_camera</span> : bool</code></dt>
<dd>
<div class="desc"><p>Indicate, if the images originate from the same camera</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def same_camera(self) -&gt; bool:
    &#34;&#34;&#34;Indicate, if the images originate from the same camera&#34;&#34;&#34;
    return self._same_camera</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.shape"><code class="name">var <span class="ident">shape</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Access the image shape</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Access the image shape&#34;&#34;&#34;
    return self.images[0].shape if self._same_camera else None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pvinspect.data.image.ImageSequence.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, fn: Callable[[<a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>], <a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>], *argv, progress_bar: bool = True, **kwargs) ‑> <a title="pvinspect.data.image.ImageSequence" href="#pvinspect.data.image.ImageSequence">ImageSequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Apply the given callable on every image. Returns a copy of the
original sequence</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fn</code></strong> :&ensp;<code>Callable[[<a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>], <a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>]</code></dt>
<dd>Callable that receives and returns an Image</dd>
<dt><strong><code>progress_bar</code></strong> :&ensp;<code>bool</code></dt>
<dd>Show progress bar?</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>sequence (ImageSequence): The copy with modified images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(
    self, fn: Callable[[Image], Image], *argv, progress_bar: bool = True, **kwargs
) -&gt; ImageSequence:
    &#34;&#34;&#34;Apply the given callable on every image. Returns a copy of the
    original sequence

    Args:
        fn (Callable[[Image], Image]): Callable that receives and returns an Image
        progress_bar (bool): Show progress bar?
    
    Returns:
        sequence (ImageSequence): The copy with modified images
    &#34;&#34;&#34;
    result = []
    p = tqdm if progress_bar else lambda x: x
    for img in p(self._images):
        result.append(fn(img, *argv, **kwargs))
    return self.from_self(images=result)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.apply_image_data"><code class="name flex">
<span>def <span class="ident">apply_image_data</span></span>(<span>self: _T, fn: Callable[[np.ndarray], np.ndarray], *argv, progress_bar: bool = True, **kwargs) ‑> _T</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the given callable on every image data. Returns a copy of the
original sequence with modified data</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fn</code></strong> :&ensp;<code>Callable[[np.ndarray], np.ndarray]</code></dt>
<dd>Callable that receives a np.ndarray
and returns a np.ndarray. Note that the argument is immutable.</dd>
<dt><strong><code>progress_bar</code></strong> :&ensp;<code>bool</code></dt>
<dd>Show progress bar?</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>sequence (ImageSequence): The copy with modified data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_image_data(
    self: _T,
    fn: Callable[[np.ndarray], np.ndarray],
    *argv,
    progress_bar: bool = True,
    **kwargs
) -&gt; _T:
    &#34;&#34;&#34;Apply the given callable on every image data. Returns a copy of the
    original sequence with modified data

    Args:
        fn (Callable[[np.ndarray], np.ndarray]): Callable that receives a np.ndarray
            and returns a np.ndarray. Note that the argument is immutable.
        progress_bar (bool): Show progress bar?
    
    Returns:
        sequence (ImageSequence): The copy with modified data
    &#34;&#34;&#34;
    result = []
    p = tqdm if progress_bar else lambda x: x
    for img in p(self._images):
        data = img.data
        res = fn(data, *argv, **kwargs)
        result.append(type(img).from_other(img, data=res))
    return self.from_self(images=result)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.as_type"><code class="name flex">
<span>def <span class="ident">as_type</span></span>(<span>self: _T, dtype: <a title="pvinspect.data.image.DType" href="#pvinspect.data.image.DType">DType</a>) ‑> _T</span>
</code></dt>
<dd>
<div class="desc"><p>Convert sequence to specified dtype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_type(self: _T, dtype: DType) -&gt; _T:
    &#34;&#34;&#34;Convert sequence to specified dtype&#34;&#34;&#34;
    result = [img.as_type(dtype) for img in self._images]
    return self.from_self(images=result)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self, N: int = 4, cols: int = 2, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the first N images</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of images to show</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code></dt>
<dd>How many images to show in a column</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self, N: int = 4, cols: int = 2, *args, **kwargs):
    &#34;&#34;&#34;Show the first N images

    Args:
        N (int): Number of images to show
        cols (int): How many images to show in a column
    &#34;&#34;&#34;
    self._show(self.images[:N], cols, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.meta_from_fn"><code class="name flex">
<span>def <span class="ident">meta_from_fn</span></span>(<span>self, fn: Callable[[<a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>], Dict[str, Any]], **kwargs) ‑> <a title="pvinspect.data.image.ImageSequence" href="#pvinspect.data.image.ImageSequence">ImageSequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Extract meta information using given function</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fn</code></strong> :&ensp;<code>Callable[[<a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a>], Dict[str, Any]]</code></dt>
<dd>Function that is applied on every element of the sequence</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meta_from_fn(
    self, fn: Callable[[Image], Dict[str, Any]], **kwargs
) -&gt; ImageSequence:
    &#34;&#34;&#34;Extract meta information using given function

    Args:
        fn (Callable[[Image], Dict[str, Any]]): Function that is applied on every element of the sequence
    &#34;&#34;&#34;
    return self.apply(fn=lambda x: x.meta_from_fn(fn), **kwargs)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.meta_from_path"><code class="name flex">
<span>def <span class="ident">meta_from_path</span></span>(<span>self, pattern: str, key: str, target_type: Type, group_n: int = 1, transform: Callable[[Any], Any] = None) ‑> <a title="pvinspect.data.image.ImageSequence" href="#pvinspect.data.image.ImageSequence">ImageSequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Extract meta information from path of individual aimges. The group_n'th matching group
from pattern is used as meta value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>Regular expression used to parse meta</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Key of the meta attribute</dd>
<dt><strong><code>target_type</code></strong> :&ensp;<code>Type</code></dt>
<dd>Result is converted to this datatype</dd>
<dt><strong><code>group_n</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of matching group</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>Callable[[Any], Any]</code></dt>
<dd>Optional function that is applied on the value
before datatype conversion</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>images (ImageSequence): Resulting ImageSequence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meta_from_path(
    self,
    pattern: str,
    key: str,
    target_type: Type,
    group_n: int = 1,
    transform: Callable[[Any], Any] = None,
) -&gt; ImageSequence:
    &#34;&#34;&#34;Extract meta information from path of individual aimges. The group_n&#39;th matching group
    from pattern is used as meta value

    Args:
        pattern (str): Regular expression used to parse meta
        key (str): Key of the meta attribute
        target_type (Type): Result is converted to this datatype
        group_n (int): Index of matching group
        transform (Callable[[Any], Any]): Optional function that is applied on the value
            before datatype conversion

    Returns:
        images (ImageSequence): Resulting ImageSequence
    &#34;&#34;&#34;
    result = []
    for img in self._images:
        result.append(
            img.meta_from_path(
                pattern=pattern,
                key=key,
                target_type=target_type,
                group_n=group_n,
                transform=transform,
            )
        )
    return self.from_self(images=result)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.meta_to_pandas"><code class="name flex">
<span>def <span class="ident">meta_to_pandas</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Convert meta from images to pandas DataFrame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meta_to_pandas(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Convert meta from images to pandas DataFrame&#34;&#34;&#34;
    if self._meta_df is None:
        series = [img._meta_to_pandas() for img in self._images]
        self._meta_df = pd.DataFrame(data=series)
        self._meta_df = self._meta_df.astype(
            {&#34;modality&#34;: str}
        )  # allow for easy comparison
    return self._meta_df.copy()  # pd.DataFrame has no writable flag :(</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ImageSequence.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self, N: int = 4, cols: int = 2, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the last N images</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of images to show</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code></dt>
<dd>How many images to show in a column</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self, N: int = 4, cols: int = 2, *args, **kwargs):
    &#34;&#34;&#34;Show the last N images

    Args:
        N (int): Number of images to show
        cols (int): How many images to show in a column
    &#34;&#34;&#34;
    self._show(self.images[-N:], cols, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pvinspect.data.image.Modality"><code class="flex name class">
<span>class <span class="ident">Modality</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Modality(Enum):
    EL_IMAGE = (0,)
    PL_IMAGE = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pvinspect.data.image.Modality.EL_IMAGE"><code class="name">var <span class="ident">EL_IMAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pvinspect.data.image.Modality.PL_IMAGE"><code class="name">var <span class="ident">PL_IMAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pvinspect.data.image.ModuleImage"><code class="flex name class">
<span>class <span class="ident">ModuleImage</span></span>
<span>(</span><span>data: np.ndarray, modality: <a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a>, path: Path = None, cols: int = None, rows: int = None, meta: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>An image of a solar module with additional meta data</p>
<p>Initialize a module image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The image data</dd>
<dt><strong><code>modality</code></strong> :&ensp;<code><a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a></code></dt>
<dd>The imaging modality</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>Path to the image</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of cells in a column</dd>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of cells in a row</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModuleImage(Image):
    &#34;&#34;&#34;An image of a solar module with additional meta data&#34;&#34;&#34;

    def __init__(
        self,
        data: np.ndarray,
        modality: Modality,
        path: Path = None,
        cols: int = None,
        rows: int = None,
        meta: dict = None,
    ):
        &#34;&#34;&#34;Initialize a module image

        Args:
            data (np.ndarray): The image data
            modality (Modality): The imaging modality
            path (Path): Path to the image
            cols (int): Number of cells in a column
            rows (int): Number of cells in a row
        &#34;&#34;&#34;

        super().__init__(data, path, modality, meta)
        self._meta[&#34;cols&#34;] = cols
        self._meta[&#34;rows&#34;] = rows

    def grid(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Create a grid of corners according to the module geometry
        
        Returns:
            grid: (cols*rows, 2)-array of coordinates on a regular grid
        &#34;&#34;&#34;

        if self.cols is not None and self.rows is not None:
            x, y = np.mgrid[0 : self.cols + 1 : 1, 0 : self.rows + 1 : 1]
            grid = np.stack([x.flatten(), y.flatten()], axis=1)
            return grid
        else:
            logging.error(&#34;Module geometry is not initialized&#34;)
            exit()

    @property
    def cols(self):
        &#34;&#34;&#34;Number of cell-columns&#34;&#34;&#34;
        return self.get_meta(&#34;cols&#34;)

    @property
    def rows(self):
        &#34;&#34;&#34;Number of row-columns&#34;&#34;&#34;
        return self.get_meta(&#34;rows&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a></li>
<li>pvinspect.data.image._Base</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pvinspect.data.image.PartialModuleImage" href="#pvinspect.data.image.PartialModuleImage">PartialModuleImage</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pvinspect.data.image.ModuleImage.cols"><code class="name">var <span class="ident">cols</span></code></dt>
<dd>
<div class="desc"><p>Number of cell-columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cols(self):
    &#34;&#34;&#34;Number of cell-columns&#34;&#34;&#34;
    return self.get_meta(&#34;cols&#34;)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.ModuleImage.rows"><code class="name">var <span class="ident">rows</span></code></dt>
<dd>
<div class="desc"><p>Number of row-columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rows(self):
    &#34;&#34;&#34;Number of row-columns&#34;&#34;&#34;
    return self.get_meta(&#34;rows&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pvinspect.data.image.ModuleImage.grid"><code class="name flex">
<span>def <span class="ident">grid</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Create a grid of corners according to the module geometry</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>grid</code></dt>
<dd>(cols*rows, 2)-array of coordinates on a regular grid</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grid(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Create a grid of corners according to the module geometry
    
    Returns:
        grid: (cols*rows, 2)-array of coordinates on a regular grid
    &#34;&#34;&#34;

    if self.cols is not None and self.rows is not None:
        x, y = np.mgrid[0 : self.cols + 1 : 1, 0 : self.rows + 1 : 1]
        grid = np.stack([x.flatten(), y.flatten()], axis=1)
        return grid
    else:
        logging.error(&#34;Module geometry is not initialized&#34;)
        exit()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a></b></code>:
<ul class="hlist">
<li><code><a title="pvinspect.data.image.Image.data" href="#pvinspect.data.image.Image.data">data</a></code></li>
<li><code><a title="pvinspect.data.image.Image.dtype" href="#pvinspect.data.image.Image.dtype">dtype</a></code></li>
<li><code><a title="pvinspect.data.image.Image.get_meta" href="#pvinspect.data.image.Image.get_meta">get_meta</a></code></li>
<li><code><a title="pvinspect.data.image.Image.has_meta" href="#pvinspect.data.image.Image.has_meta">has_meta</a></code></li>
<li><code><a title="pvinspect.data.image.Image.lazy" href="#pvinspect.data.image.Image.lazy">lazy</a></code></li>
<li><code><a title="pvinspect.data.image.Image.list_meta" href="#pvinspect.data.image.Image.list_meta">list_meta</a></code></li>
<li><code><a title="pvinspect.data.image.Image.meta_from_fn" href="#pvinspect.data.image.Image.meta_from_fn">meta_from_fn</a></code></li>
<li><code><a title="pvinspect.data.image.Image.meta_from_path" href="#pvinspect.data.image.Image.meta_from_path">meta_from_path</a></code></li>
<li><code><a title="pvinspect.data.image.Image.meta_to_pandas" href="#pvinspect.data.image.Image.meta_to_pandas">meta_to_pandas</a></code></li>
<li><code><a title="pvinspect.data.image.Image.modality" href="#pvinspect.data.image.Image.modality">modality</a></code></li>
<li><code><a title="pvinspect.data.image.Image.path" href="#pvinspect.data.image.Image.path">path</a></code></li>
<li><code><a title="pvinspect.data.image.Image.shape" href="#pvinspect.data.image.Image.shape">shape</a></code></li>
<li><code><a title="pvinspect.data.image.Image.show" href="#pvinspect.data.image.Image.show">show</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pvinspect.data.image.ModuleImageSequence"><code class="flex name class">
<span>class <span class="ident">ModuleImageSequence</span></span>
<span>(</span><span>images: List[ModuleOrPartialModuleImage], same_camera: bool = False, allow_different_dtypes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>An immutable sequence of module images, allowing for access to single images as well as analysis of the sequence</p>
<p>Initialize a module image sequence</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>List[<a title="pvinspect.data.image.ModuleImage" href="#pvinspect.data.image.ModuleImage">ModuleImage</a>]</code></dt>
<dd>The list of images</dd>
<dt><strong><code>same_camera</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if all images are from the same camera</dd>
<dt><strong><code>allow_different_dtypes</code></strong> :&ensp;<code>bool</code></dt>
<dd>Allow images to have different datatypes?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModuleImageSequence(ImageSequence):
    &#34;&#34;&#34;An immutable sequence of module images, allowing for access to single images as well as analysis of the sequence&#34;&#34;&#34;

    def __init__(
        self,
        images: List[ModuleOrPartialModuleImage],
        same_camera: bool = False,
        allow_different_dtypes=False,
    ):
        &#34;&#34;&#34;Initialize a module image sequence
        
        Args:
            images (List[ModuleImage]): The list of images
            same_camera (bool): Indicates if all images are from the same camera
            allow_different_dtypes (bool): Allow images to have different datatypes?
        &#34;&#34;&#34;

        cols = images[0].cols
        rows = images[0].rows
        for img in images:
            if img.cols != cols:
                logging.error(
                    &#34;Cannot create sequence from different module configurations&#34;
                )
                exit()
            if img.rows != rows:
                logging.error(
                    &#34;Cannot create sequence from different module configurations&#34;
                )
                exit()

        super().__init__(images, same_camera, allow_different_dtypes)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pvinspect.data.image.ImageSequence" href="#pvinspect.data.image.ImageSequence">ImageSequence</a></li>
<li>pvinspect.data.image._Base</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pvinspect.data.image.ImageSequence" href="#pvinspect.data.image.ImageSequence">ImageSequence</a></b></code>:
<ul class="hlist">
<li><code><a title="pvinspect.data.image.ImageSequence.apply" href="#pvinspect.data.image.ImageSequence.apply">apply</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.apply_image_data" href="#pvinspect.data.image.ImageSequence.apply_image_data">apply_image_data</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.as_type" href="#pvinspect.data.image.ImageSequence.as_type">as_type</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.dtype" href="#pvinspect.data.image.ImageSequence.dtype">dtype</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.head" href="#pvinspect.data.image.ImageSequence.head">head</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.images" href="#pvinspect.data.image.ImageSequence.images">images</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.meta_from_fn" href="#pvinspect.data.image.ImageSequence.meta_from_fn">meta_from_fn</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.meta_from_path" href="#pvinspect.data.image.ImageSequence.meta_from_path">meta_from_path</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.meta_to_pandas" href="#pvinspect.data.image.ImageSequence.meta_to_pandas">meta_to_pandas</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.modality" href="#pvinspect.data.image.ImageSequence.modality">modality</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.same_camera" href="#pvinspect.data.image.ImageSequence.same_camera">same_camera</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.shape" href="#pvinspect.data.image.ImageSequence.shape">shape</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.tail" href="#pvinspect.data.image.ImageSequence.tail">tail</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pvinspect.data.image.PartialModuleImage"><code class="flex name class">
<span>class <span class="ident">PartialModuleImage</span></span>
<span>(</span><span>data: np.ndarray, modality: <a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a>, path: Path = None, cols: int = None, rows: int = None, first_col: int = None, first_row: int = None, meta: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>An image of a solar module with additional meta data</p>
<p>Initialize a module image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The image data</dd>
<dt><strong><code>modality</code></strong> :&ensp;<code><a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a></code></dt>
<dd>The imaging modality</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code></dt>
<dd>Path to the image</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of completely visible cells in a column</dd>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of completely visible cells in a row</dd>
<dt><strong><code>first_col</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the first complete column shown</dd>
<dt><strong><code>first_row</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the first complete row shown</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartialModuleImage(ModuleImage):
    &#34;&#34;&#34;An image of a solar module with additional meta data&#34;&#34;&#34;

    def __init__(
        self,
        data: np.ndarray,
        modality: Modality,
        path: Path = None,
        cols: int = None,
        rows: int = None,
        first_col: int = None,
        first_row: int = None,
        meta: dict = None,
    ):
        &#34;&#34;&#34;Initialize a module image

        Args:
            data (np.ndarray): The image data
            modality (Modality): The imaging modality
            path (Path): Path to the image
            cols (int): Number of completely visible cells in a column
            rows (int): Number of completely visible cells in a row
            first_col (int): Index of the first complete column shown
            first_row (int): Index of the first complete row shown
        &#34;&#34;&#34;

        super().__init__(data, modality, path, cols, rows, meta)

        self._meta[&#34;first_col&#34;] = first_col
        self._meta[&#34;first_row&#34;] = first_row

    def grid(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Create a grid of corners according to the module geometry
        
        Returns:
            grid: (cols*rows, 2)-array of coordinates on a regular grid
        &#34;&#34;&#34;

        if self.cols is not None and self.rows is not None:
            x, y = np.mgrid[0 : self.cols + 1 : 1, 0 : self.rows + 1 : 1]
            x += self.first_col
            y += self.first_row
            grid = np.stack([x.flatten(), y.flatten()], axis=1)
            return grid
        else:
            logging.error(&#34;Module geometry is not initialized&#34;)
            exit()

    @property
    def first_col(self) -&gt; Optional[int]:
        if self.has_meta(&#34;first_col&#34;):
            return self.get_meta(&#34;first_col&#34;)
        else:
            return None

    @property
    def first_row(self) -&gt; Optional[int]:
        if self.has_meta(&#34;first_row&#34;):
            return self.get_meta(&#34;first_row&#34;)
        else:
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pvinspect.data.image.ModuleImage" href="#pvinspect.data.image.ModuleImage">ModuleImage</a></li>
<li><a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a></li>
<li>pvinspect.data.image._Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pvinspect.data.image.PartialModuleImage.first_col"><code class="name">var <span class="ident">first_col</span> : Union[int, NoneType]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_col(self) -&gt; Optional[int]:
    if self.has_meta(&#34;first_col&#34;):
        return self.get_meta(&#34;first_col&#34;)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pvinspect.data.image.PartialModuleImage.first_row"><code class="name">var <span class="ident">first_row</span> : Union[int, NoneType]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_row(self) -&gt; Optional[int]:
    if self.has_meta(&#34;first_row&#34;):
        return self.get_meta(&#34;first_row&#34;)
    else:
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pvinspect.data.image.ModuleImage" href="#pvinspect.data.image.ModuleImage">ModuleImage</a></b></code>:
<ul class="hlist">
<li><code><a title="pvinspect.data.image.ModuleImage.cols" href="#pvinspect.data.image.ModuleImage.cols">cols</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.data" href="#pvinspect.data.image.Image.data">data</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.dtype" href="#pvinspect.data.image.Image.dtype">dtype</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.get_meta" href="#pvinspect.data.image.Image.get_meta">get_meta</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.grid" href="#pvinspect.data.image.ModuleImage.grid">grid</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.has_meta" href="#pvinspect.data.image.Image.has_meta">has_meta</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.lazy" href="#pvinspect.data.image.Image.lazy">lazy</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.list_meta" href="#pvinspect.data.image.Image.list_meta">list_meta</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.meta_from_fn" href="#pvinspect.data.image.Image.meta_from_fn">meta_from_fn</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.meta_from_path" href="#pvinspect.data.image.Image.meta_from_path">meta_from_path</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.meta_to_pandas" href="#pvinspect.data.image.Image.meta_to_pandas">meta_to_pandas</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.modality" href="#pvinspect.data.image.Image.modality">modality</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.path" href="#pvinspect.data.image.Image.path">path</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.rows" href="#pvinspect.data.image.ModuleImage.rows">rows</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.shape" href="#pvinspect.data.image.Image.shape">shape</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.show" href="#pvinspect.data.image.Image.show">show</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pvinspect.data" href="index.html">pvinspect.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pvinspect.data.image.EL_IMAGE" href="#pvinspect.data.image.EL_IMAGE">EL_IMAGE</a></code></li>
<li><code><a title="pvinspect.data.image.PL_IMAGE" href="#pvinspect.data.image.PL_IMAGE">PL_IMAGE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pvinspect.data.image.register_show_plugin" href="#pvinspect.data.image.register_show_plugin">register_show_plugin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pvinspect.data.image.CellImage" href="#pvinspect.data.image.CellImage">CellImage</a></code></h4>
<ul class="">
<li><code><a title="pvinspect.data.image.CellImage.col" href="#pvinspect.data.image.CellImage.col">col</a></code></li>
<li><code><a title="pvinspect.data.image.CellImage.path" href="#pvinspect.data.image.CellImage.path">path</a></code></li>
<li><code><a title="pvinspect.data.image.CellImage.row" href="#pvinspect.data.image.CellImage.row">row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pvinspect.data.image.CellImageSequence" href="#pvinspect.data.image.CellImageSequence">CellImageSequence</a></code></h4>
</li>
<li>
<h4><code><a title="pvinspect.data.image.DType" href="#pvinspect.data.image.DType">DType</a></code></h4>
<ul class="">
<li><code><a title="pvinspect.data.image.DType.FLOAT" href="#pvinspect.data.image.DType.FLOAT">FLOAT</a></code></li>
<li><code><a title="pvinspect.data.image.DType.INT" href="#pvinspect.data.image.DType.INT">INT</a></code></li>
<li><code><a title="pvinspect.data.image.DType.UNSIGNED_BYTE" href="#pvinspect.data.image.DType.UNSIGNED_BYTE">UNSIGNED_BYTE</a></code></li>
<li><code><a title="pvinspect.data.image.DType.UNSIGNED_INT" href="#pvinspect.data.image.DType.UNSIGNED_INT">UNSIGNED_INT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pvinspect.data.image.Image" href="#pvinspect.data.image.Image">Image</a></code></h4>
<ul class="two-column">
<li><code><a title="pvinspect.data.image.Image.LazyData" href="#pvinspect.data.image.Image.LazyData">LazyData</a></code></li>
<li><code><a title="pvinspect.data.image.Image.as_type" href="#pvinspect.data.image.Image.as_type">as_type</a></code></li>
<li><code><a title="pvinspect.data.image.Image.data" href="#pvinspect.data.image.Image.data">data</a></code></li>
<li><code><a title="pvinspect.data.image.Image.dtype" href="#pvinspect.data.image.Image.dtype">dtype</a></code></li>
<li><code><a title="pvinspect.data.image.Image.get_meta" href="#pvinspect.data.image.Image.get_meta">get_meta</a></code></li>
<li><code><a title="pvinspect.data.image.Image.has_meta" href="#pvinspect.data.image.Image.has_meta">has_meta</a></code></li>
<li><code><a title="pvinspect.data.image.Image.lazy" href="#pvinspect.data.image.Image.lazy">lazy</a></code></li>
<li><code><a title="pvinspect.data.image.Image.list_meta" href="#pvinspect.data.image.Image.list_meta">list_meta</a></code></li>
<li><code><a title="pvinspect.data.image.Image.meta_from_fn" href="#pvinspect.data.image.Image.meta_from_fn">meta_from_fn</a></code></li>
<li><code><a title="pvinspect.data.image.Image.meta_from_path" href="#pvinspect.data.image.Image.meta_from_path">meta_from_path</a></code></li>
<li><code><a title="pvinspect.data.image.Image.meta_to_pandas" href="#pvinspect.data.image.Image.meta_to_pandas">meta_to_pandas</a></code></li>
<li><code><a title="pvinspect.data.image.Image.modality" href="#pvinspect.data.image.Image.modality">modality</a></code></li>
<li><code><a title="pvinspect.data.image.Image.path" href="#pvinspect.data.image.Image.path">path</a></code></li>
<li><code><a title="pvinspect.data.image.Image.shape" href="#pvinspect.data.image.Image.shape">shape</a></code></li>
<li><code><a title="pvinspect.data.image.Image.show" href="#pvinspect.data.image.Image.show">show</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pvinspect.data.image.ImageSequence" href="#pvinspect.data.image.ImageSequence">ImageSequence</a></code></h4>
<ul class="two-column">
<li><code><a title="pvinspect.data.image.ImageSequence.apply" href="#pvinspect.data.image.ImageSequence.apply">apply</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.apply_image_data" href="#pvinspect.data.image.ImageSequence.apply_image_data">apply_image_data</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.as_type" href="#pvinspect.data.image.ImageSequence.as_type">as_type</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.dtype" href="#pvinspect.data.image.ImageSequence.dtype">dtype</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.head" href="#pvinspect.data.image.ImageSequence.head">head</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.images" href="#pvinspect.data.image.ImageSequence.images">images</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.meta_from_fn" href="#pvinspect.data.image.ImageSequence.meta_from_fn">meta_from_fn</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.meta_from_path" href="#pvinspect.data.image.ImageSequence.meta_from_path">meta_from_path</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.meta_to_pandas" href="#pvinspect.data.image.ImageSequence.meta_to_pandas">meta_to_pandas</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.modality" href="#pvinspect.data.image.ImageSequence.modality">modality</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.same_camera" href="#pvinspect.data.image.ImageSequence.same_camera">same_camera</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.shape" href="#pvinspect.data.image.ImageSequence.shape">shape</a></code></li>
<li><code><a title="pvinspect.data.image.ImageSequence.tail" href="#pvinspect.data.image.ImageSequence.tail">tail</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pvinspect.data.image.Modality" href="#pvinspect.data.image.Modality">Modality</a></code></h4>
<ul class="">
<li><code><a title="pvinspect.data.image.Modality.EL_IMAGE" href="#pvinspect.data.image.Modality.EL_IMAGE">EL_IMAGE</a></code></li>
<li><code><a title="pvinspect.data.image.Modality.PL_IMAGE" href="#pvinspect.data.image.Modality.PL_IMAGE">PL_IMAGE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pvinspect.data.image.ModuleImage" href="#pvinspect.data.image.ModuleImage">ModuleImage</a></code></h4>
<ul class="">
<li><code><a title="pvinspect.data.image.ModuleImage.cols" href="#pvinspect.data.image.ModuleImage.cols">cols</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.grid" href="#pvinspect.data.image.ModuleImage.grid">grid</a></code></li>
<li><code><a title="pvinspect.data.image.ModuleImage.rows" href="#pvinspect.data.image.ModuleImage.rows">rows</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pvinspect.data.image.ModuleImageSequence" href="#pvinspect.data.image.ModuleImageSequence">ModuleImageSequence</a></code></h4>
</li>
<li>
<h4><code><a title="pvinspect.data.image.PartialModuleImage" href="#pvinspect.data.image.PartialModuleImage">PartialModuleImage</a></code></h4>
<ul class="">
<li><code><a title="pvinspect.data.image.PartialModuleImage.first_col" href="#pvinspect.data.image.PartialModuleImage.first_col">first_col</a></code></li>
<li><code><a title="pvinspect.data.image.PartialModuleImage.first_row" href="#pvinspect.data.image.PartialModuleImage.first_row">first_row</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>